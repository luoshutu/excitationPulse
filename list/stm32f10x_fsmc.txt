; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_fsmc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_·­Ò³\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\stm32f10x_fsmc.crf FWlib\SRC\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;101      */
;;;102    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  b930              CBNZ     r0,|L1.16|
;;;103    {
;;;104      /* Check the parameter */
;;;105      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;106      
;;;107      /* FSMC_Bank1_NORSRAM1 */
;;;108      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;109      {
;;;110        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
000002  f24302db          MOV      r2,#0x30db
000006  0081              LSLS     r1,r0,#2
000008  f1a141c0          SUB      r1,r1,#0x60000000
00000c  600a              STR      r2,[r1,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;111      }
;;;112      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;113      else
;;;114      {   
;;;115        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000010  f24302d2          MOV      r2,#0x30d2
000014  0081              LSLS     r1,r0,#2
000016  f1a141c0          SUB      r1,r1,#0x60000000
00001a  600a              STR      r2,[r1,#0]
                  |L1.28|
;;;116      }
;;;117      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  1c41              ADDS     r1,r0,#1
000022  0089              LSLS     r1,r1,#2
000024  f1a141c0          SUB      r1,r1,#0x60000000
000028  600a              STR      r2,[r1,#0]
;;;118      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00002a  0081              LSLS     r1,r0,#2
00002c  f1a141c0          SUB      r1,r1,#0x60000000
000030  f8c12104          STR      r2,[r1,#0x104]
;;;119    }
000034  4770              BX       lr
;;;120    
                          ENDP

                  FSMC_NANDDeInit PROC
;;;128      */
;;;129    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000036  2810              CMP      r0,#0x10
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;133      
;;;134      if(FSMC_Bank == FSMC_Bank2_NAND)
000038  d10a              BNE      |L1.80|
;;;135      {
;;;136        /* Set the FSMC_Bank2 registers to their reset values */
;;;137        FSMC_Bank2->PCR2 = 0x00000018;
00003a  2118              MOVS     r1,#0x18
00003c  f04f4220          MOV      r2,#0xa0000000
000040  6611              STR      r1,[r2,#0x60]
;;;138        FSMC_Bank2->SR2 = 0x00000040;
000042  2140              MOVS     r1,#0x40
000044  6651              STR      r1,[r2,#0x64]
;;;139        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000046  f04f31fc          MOV      r1,#0xfcfcfcfc
00004a  6691              STR      r1,[r2,#0x68]
;;;140        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
00004c  66d1              STR      r1,[r2,#0x6c]
00004e  e010              B        |L1.114|
                  |L1.80|
;;;141      }
;;;142      /* FSMC_Bank3_NAND */  
;;;143      else
;;;144      {
;;;145        /* Set the FSMC_Bank3 registers to their reset values */
;;;146        FSMC_Bank3->PCR3 = 0x00000018;
000050  2118              MOVS     r1,#0x18
000052  4af7              LDR      r2,|L1.1072|
000054  6011              STR      r1,[r2,#0]
;;;147        FSMC_Bank3->SR3 = 0x00000040;
000056  2140              MOVS     r1,#0x40
000058  f04f4220          MOV      r2,#0xa0000000
00005c  f8c21084          STR      r1,[r2,#0x84]
;;;148        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000060  f04f31fc          MOV      r1,#0xfcfcfcfc
000064  4af2              LDR      r2,|L1.1072|
000066  3208              ADDS     r2,r2,#8
000068  6011              STR      r1,[r2,#0]
;;;149        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00006a  f04f4220          MOV      r2,#0xa0000000
00006e  f8c2108c          STR      r1,[r2,#0x8c]
                  |L1.114|
;;;150      }  
;;;151    }
000072  4770              BX       lr
;;;152    
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;157      */
;;;158    void FSMC_PCCARDDeInit(void)
000074  2018              MOVS     r0,#0x18
;;;159    {
;;;160      /* Set the FSMC_Bank4 registers to their reset values */
;;;161      FSMC_Bank4->PCR4 = 0x00000018; 
000076  49ee              LDR      r1,|L1.1072|
000078  3120              ADDS     r1,r1,#0x20
00007a  6008              STR      r0,[r1,#0]
;;;162      FSMC_Bank4->SR4 = 0x00000000;	
00007c  2000              MOVS     r0,#0
00007e  0609              LSLS     r1,r1,#24
000080  f8c100a4          STR      r0,[r1,#0xa4]
;;;163      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
000084  f04f30fc          MOV      r0,#0xfcfcfcfc
000088  49e9              LDR      r1,|L1.1072|
00008a  3128              ADDS     r1,r1,#0x28
00008c  6008              STR      r0,[r1,#0]
;;;164      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
00008e  1d09              ADDS     r1,r1,#4
000090  6008              STR      r0,[r1,#0]
;;;165      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000092  1d09              ADDS     r1,r1,#4
000094  6008              STR      r0,[r1,#0]
;;;166    }
000096  4770              BX       lr
;;;167    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;175      */
;;;176    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000098  e9d01201          LDRD     r1,r2,[r0,#4]
;;;177    { 
;;;178      /* Check the parameters */
;;;179      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;180      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;181      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;182      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;183      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;184      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;185      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;186      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;187      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;188      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;189      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;190      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;191      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;192      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;193      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;194      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;195      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;196      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;197      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;198      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;199      
;;;200      /* Bank1 NOR/SRAM control register configuration */ 
;;;201      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
00009c  4311              ORRS     r1,r1,r2
00009e  68c2              LDR      r2,[r0,#0xc]
0000a0  4311              ORRS     r1,r1,r2
0000a2  6902              LDR      r2,[r0,#0x10]
0000a4  4311              ORRS     r1,r1,r2
0000a6  6942              LDR      r2,[r0,#0x14]
0000a8  4311              ORRS     r1,r1,r2
0000aa  6982              LDR      r2,[r0,#0x18]
0000ac  4311              ORRS     r1,r1,r2
0000ae  69c2              LDR      r2,[r0,#0x1c]
0000b0  4311              ORRS     r1,r1,r2
0000b2  6a02              LDR      r2,[r0,#0x20]
0000b4  4311              ORRS     r1,r1,r2
0000b6  6a42              LDR      r2,[r0,#0x24]
0000b8  4311              ORRS     r1,r1,r2
0000ba  6a82              LDR      r2,[r0,#0x28]
0000bc  4311              ORRS     r1,r1,r2
0000be  6ac2              LDR      r2,[r0,#0x2c]
0000c0  4311              ORRS     r1,r1,r2
0000c2  6b02              LDR      r2,[r0,#0x30]
0000c4  4311              ORRS     r1,r1,r2
0000c6  6802              LDR      r2,[r0,#0]
0000c8  0092              LSLS     r2,r2,#2
0000ca  f1a242c0          SUB      r2,r2,#0x60000000
0000ce  6011              STR      r1,[r2,#0]
;;;202                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;203                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;204                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;205                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;206                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;209                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;211                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;212                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;213                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;214    
;;;215      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
0000d0  6881              LDR      r1,[r0,#8]
0000d2  2908              CMP      r1,#8
0000d4  d10b              BNE      |L1.238|
;;;216      {
;;;217        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
0000d6  6801              LDR      r1,[r0,#0]
0000d8  0089              LSLS     r1,r1,#2
0000da  f1a141c0          SUB      r1,r1,#0x60000000
0000de  6809              LDR      r1,[r1,#0]
0000e0  f0410240          ORR      r2,r1,#0x40
0000e4  6801              LDR      r1,[r0,#0]
0000e6  0089              LSLS     r1,r1,#2
0000e8  f1a141c0          SUB      r1,r1,#0x60000000
0000ec  600a              STR      r2,[r1,#0]
                  |L1.238|
;;;218      }
;;;219      
;;;220      /* Bank1 NOR/SRAM timing register configuration */
;;;221      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
0000ee  6b41              LDR      r1,[r0,#0x34]
0000f0  6809              LDR      r1,[r1,#0]
0000f2  6b42              LDR      r2,[r0,#0x34]
0000f4  6852              LDR      r2,[r2,#4]
0000f6  ea411102          ORR      r1,r1,r2,LSL #4
0000fa  6b42              LDR      r2,[r0,#0x34]
0000fc  6892              LDR      r2,[r2,#8]
0000fe  ea412102          ORR      r1,r1,r2,LSL #8
000102  6b42              LDR      r2,[r0,#0x34]
000104  8992              LDRH     r2,[r2,#0xc]
000106  ea414102          ORR      r1,r1,r2,LSL #16
00010a  6b42              LDR      r2,[r0,#0x34]
00010c  8a12              LDRH     r2,[r2,#0x10]
00010e  ea415102          ORR      r1,r1,r2,LSL #20
000112  6b42              LDR      r2,[r0,#0x34]
000114  7d12              LDRB     r2,[r2,#0x14]
000116  ea416102          ORR      r1,r1,r2,LSL #24
00011a  6b42              LDR      r2,[r0,#0x34]
00011c  6992              LDR      r2,[r2,#0x18]
00011e  4311              ORRS     r1,r1,r2
000120  6802              LDR      r2,[r0,#0]
000122  1c52              ADDS     r2,r2,#1
000124  0092              LSLS     r2,r2,#2
000126  f1a242c0          SUB      r2,r2,#0x60000000
00012a  6011              STR      r1,[r2,#0]
;;;222                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;223                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;228                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;229                
;;;230        
;;;231      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;232      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
00012c  6ac1              LDR      r1,[r0,#0x2c]
00012e  f5b14f80          CMP      r1,#0x4000
000132  d11b              BNE      |L1.364|
;;;233      {
;;;234        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;235        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;236        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;237        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;238        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;239        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;240        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000134  6b81              LDR      r1,[r0,#0x38]
000136  6809              LDR      r1,[r1,#0]
000138  6b82              LDR      r2,[r0,#0x38]
00013a  6852              LDR      r2,[r2,#4]
00013c  ea411102          ORR      r1,r1,r2,LSL #4
000140  6b82              LDR      r2,[r0,#0x38]
000142  6892              LDR      r2,[r2,#8]
000144  ea412102          ORR      r1,r1,r2,LSL #8
000148  6b82              LDR      r2,[r0,#0x38]
00014a  8a12              LDRH     r2,[r2,#0x10]
00014c  ea415102          ORR      r1,r1,r2,LSL #20
000150  6b82              LDR      r2,[r0,#0x38]
000152  7d12              LDRB     r2,[r2,#0x14]
000154  ea416102          ORR      r1,r1,r2,LSL #24
000158  6b82              LDR      r2,[r0,#0x38]
00015a  6992              LDR      r2,[r2,#0x18]
00015c  4311              ORRS     r1,r1,r2
00015e  6802              LDR      r2,[r0,#0]
000160  0092              LSLS     r2,r2,#2
000162  f1a242c0          SUB      r2,r2,#0x60000000
000166  f8c21104          STR      r1,[r2,#0x104]
00016a  e007              B        |L1.380|
                  |L1.364|
;;;241                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;242                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;243                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;244                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;245                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;246                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;247      }
;;;248      else
;;;249      {
;;;250        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
00016c  f06f4270          MVN      r2,#0xf0000000
000170  6801              LDR      r1,[r0,#0]
000172  0089              LSLS     r1,r1,#2
000174  f1a141c0          SUB      r1,r1,#0x60000000
000178  f8c12104          STR      r2,[r1,#0x104]
                  |L1.380|
;;;251      }
;;;252    }
00017c  4770              BX       lr
;;;253    
                          ENDP

                  FSMC_NANDInit PROC
;;;261      */
;;;262    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
00017e  b530              PUSH     {r4,r5,lr}
;;;263    {
;;;264      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
000180  2100              MOVS     r1,#0
000182  2200              MOVS     r2,#0
000184  2300              MOVS     r3,#0
;;;265        
;;;266      /* Check the parameters */
;;;267      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;268      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;269      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;270      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;271      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;272      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;273      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;274      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;275      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;276      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;277      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;278      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;279      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;280      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;281      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;282      
;;;283      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;284      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000186  6844              LDR      r4,[r0,#4]
000188  f0440408          ORR      r4,r4,#8
00018c  6885              LDR      r5,[r0,#8]
00018e  432c              ORRS     r4,r4,r5
000190  68c5              LDR      r5,[r0,#0xc]
000192  432c              ORRS     r4,r4,r5
000194  6905              LDR      r5,[r0,#0x10]
000196  432c              ORRS     r4,r4,r5
000198  6945              LDR      r5,[r0,#0x14]
00019a  ea442445          ORR      r4,r4,r5,LSL #9
00019e  6985              LDR      r5,[r0,#0x18]
0001a0  ea443145          ORR      r1,r4,r5,LSL #13
;;;285                PCR_MemoryType_NAND |
;;;286                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;287                FSMC_NANDInitStruct->FSMC_ECC |
;;;288                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;289                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;290                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;291                
;;;292      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;293      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0001a4  69c4              LDR      r4,[r0,#0x1c]
0001a6  6824              LDR      r4,[r4,#0]
0001a8  69c5              LDR      r5,[r0,#0x1c]
0001aa  686d              LDR      r5,[r5,#4]
0001ac  ea442405          ORR      r4,r4,r5,LSL #8
0001b0  69c5              LDR      r5,[r0,#0x1c]
0001b2  892d              LDRH     r5,[r5,#8]
0001b4  ea444405          ORR      r4,r4,r5,LSL #16
0001b8  69c5              LDR      r5,[r0,#0x1c]
0001ba  7b2d              LDRB     r5,[r5,#0xc]
0001bc  ea446205          ORR      r2,r4,r5,LSL #24
;;;294                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;295                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;296                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;297                
;;;298      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;299      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0001c0  6a04              LDR      r4,[r0,#0x20]
0001c2  6824              LDR      r4,[r4,#0]
0001c4  6a05              LDR      r5,[r0,#0x20]
0001c6  686d              LDR      r5,[r5,#4]
0001c8  ea442405          ORR      r4,r4,r5,LSL #8
0001cc  6a05              LDR      r5,[r0,#0x20]
0001ce  892d              LDRH     r5,[r5,#8]
0001d0  ea444405          ORR      r4,r4,r5,LSL #16
0001d4  6a05              LDR      r5,[r0,#0x20]
0001d6  7b2d              LDRB     r5,[r5,#0xc]
0001d8  ea446305          ORR      r3,r4,r5,LSL #24
;;;300                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;301                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;302                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;303      
;;;304      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
0001dc  6804              LDR      r4,[r0,#0]
0001de  2c10              CMP      r4,#0x10
0001e0  d105              BNE      |L1.494|
;;;305      {
;;;306        /* FSMC_Bank2_NAND registers configuration */
;;;307        FSMC_Bank2->PCR2 = tmppcr;
0001e2  f04f4420          MOV      r4,#0xa0000000
0001e6  6621              STR      r1,[r4,#0x60]
;;;308        FSMC_Bank2->PMEM2 = tmppmem;
0001e8  66a2              STR      r2,[r4,#0x68]
;;;309        FSMC_Bank2->PATT2 = tmppatt;
0001ea  66e3              STR      r3,[r4,#0x6c]
0001ec  e008              B        |L1.512|
                  |L1.494|
;;;310      }
;;;311      else
;;;312      {
;;;313        /* FSMC_Bank3_NAND registers configuration */
;;;314        FSMC_Bank3->PCR3 = tmppcr;
0001ee  4c90              LDR      r4,|L1.1072|
0001f0  6021              STR      r1,[r4,#0]
;;;315        FSMC_Bank3->PMEM3 = tmppmem;
0001f2  f04f4420          MOV      r4,#0xa0000000
0001f6  f8c42088          STR      r2,[r4,#0x88]
;;;316        FSMC_Bank3->PATT3 = tmppatt;
0001fa  4c8d              LDR      r4,|L1.1072|
0001fc  340c              ADDS     r4,r4,#0xc
0001fe  6023              STR      r3,[r4,#0]
                  |L1.512|
;;;317      }
;;;318    }
000200  bd30              POP      {r4,r5,pc}
;;;319    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;327      */
;;;328    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000202  6801              LDR      r1,[r0,#0]
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;332      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;333      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;334     
;;;335      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;336      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;337      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;338      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;339      
;;;340      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;341      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;342      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;343      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;344      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;345      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;346      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;347      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;348      
;;;349      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;350      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000204  f0410110          ORR      r1,r1,#0x10
000208  6842              LDR      r2,[r0,#4]
00020a  ea412142          ORR      r1,r1,r2,LSL #9
00020e  6882              LDR      r2,[r0,#8]
000210  ea413142          ORR      r1,r1,r2,LSL #13
000214  4a86              LDR      r2,|L1.1072|
000216  3220              ADDS     r2,r2,#0x20
000218  6011              STR      r1,[r2,#0]
;;;351                         FSMC_MemoryDataWidth_16b |  
;;;352                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;353                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;354                
;;;355      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;356      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00021a  68c1              LDR      r1,[r0,#0xc]
00021c  6809              LDR      r1,[r1,#0]
00021e  68c2              LDR      r2,[r0,#0xc]
000220  6852              LDR      r2,[r2,#4]
000222  ea412102          ORR      r1,r1,r2,LSL #8
000226  68c2              LDR      r2,[r0,#0xc]
000228  8912              LDRH     r2,[r2,#8]
00022a  ea414102          ORR      r1,r1,r2,LSL #16
00022e  68c2              LDR      r2,[r0,#0xc]
000230  7b12              LDRB     r2,[r2,#0xc]
000232  ea416102          ORR      r1,r1,r2,LSL #24
000236  4a7e              LDR      r2,|L1.1072|
000238  3228              ADDS     r2,r2,#0x28
00023a  6011              STR      r1,[r2,#0]
;;;357                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;358                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;359                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;360                
;;;361      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;362      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00023c  6901              LDR      r1,[r0,#0x10]
00023e  6809              LDR      r1,[r1,#0]
000240  6902              LDR      r2,[r0,#0x10]
000242  6852              LDR      r2,[r2,#4]
000244  ea412102          ORR      r1,r1,r2,LSL #8
000248  6902              LDR      r2,[r0,#0x10]
00024a  8912              LDRH     r2,[r2,#8]
00024c  ea414102          ORR      r1,r1,r2,LSL #16
000250  6902              LDR      r2,[r0,#0x10]
000252  7b12              LDRB     r2,[r2,#0xc]
000254  ea416102          ORR      r1,r1,r2,LSL #24
000258  4a75              LDR      r2,|L1.1072|
00025a  322c              ADDS     r2,r2,#0x2c
00025c  6011              STR      r1,[r2,#0]
;;;363                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;364                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;365                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;366                
;;;367      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;368      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
00025e  6941              LDR      r1,[r0,#0x14]
000260  6809              LDR      r1,[r1,#0]
000262  6942              LDR      r2,[r0,#0x14]
000264  6852              LDR      r2,[r2,#4]
000266  ea412102          ORR      r1,r1,r2,LSL #8
00026a  6942              LDR      r2,[r0,#0x14]
00026c  8912              LDRH     r2,[r2,#8]
00026e  ea414102          ORR      r1,r1,r2,LSL #16
000272  6942              LDR      r2,[r0,#0x14]
000274  7b12              LDRB     r2,[r2,#0xc]
000276  ea416102          ORR      r1,r1,r2,LSL #24
00027a  f04f4220          MOV      r2,#0xa0000000
00027e  f8c210b0          STR      r1,[r2,#0xb0]
;;;369                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;370                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;371                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;372    }
000282  4770              BX       lr
;;;373    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;379      */
;;;380    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000284  2100              MOVS     r1,#0
;;;381    {  
;;;382      /* Reset NOR/SRAM Init structure parameters values */
;;;383      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000286  6001              STR      r1,[r0,#0]
;;;384      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000288  2102              MOVS     r1,#2
00028a  6041              STR      r1,[r0,#4]
;;;385      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
00028c  2100              MOVS     r1,#0
00028e  6081              STR      r1,[r0,#8]
;;;386      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000290  60c1              STR      r1,[r0,#0xc]
;;;387      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
000292  6101              STR      r1,[r0,#0x10]
;;;388      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
000294  6141              STR      r1,[r0,#0x14]
;;;389      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000296  6181              STR      r1,[r0,#0x18]
;;;390      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000298  61c1              STR      r1,[r0,#0x1c]
;;;391      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
00029a  6201              STR      r1,[r0,#0x20]
;;;392      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
00029c  f44f5180          MOV      r1,#0x1000
0002a0  6241              STR      r1,[r0,#0x24]
;;;393      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
0002a2  0049              LSLS     r1,r1,#1
0002a4  6281              STR      r1,[r0,#0x28]
;;;394      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
0002a6  2100              MOVS     r1,#0
0002a8  62c1              STR      r1,[r0,#0x2c]
;;;395      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
0002aa  6301              STR      r1,[r0,#0x30]
;;;396      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
0002ac  210f              MOVS     r1,#0xf
0002ae  6b42              LDR      r2,[r0,#0x34]
0002b0  6011              STR      r1,[r2,#0]
;;;397      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
0002b2  6b42              LDR      r2,[r0,#0x34]
0002b4  6051              STR      r1,[r2,#4]
;;;398      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
0002b6  21ff              MOVS     r1,#0xff
0002b8  6b42              LDR      r2,[r0,#0x34]
0002ba  6091              STR      r1,[r2,#8]
;;;399      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
0002bc  210f              MOVS     r1,#0xf
0002be  6b42              LDR      r2,[r0,#0x34]
0002c0  60d1              STR      r1,[r2,#0xc]
;;;400      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
0002c2  6b42              LDR      r2,[r0,#0x34]
0002c4  6111              STR      r1,[r2,#0x10]
;;;401      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
0002c6  6b42              LDR      r2,[r0,#0x34]
0002c8  6151              STR      r1,[r2,#0x14]
;;;402      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
0002ca  2100              MOVS     r1,#0
0002cc  6b42              LDR      r2,[r0,#0x34]
0002ce  6191              STR      r1,[r2,#0x18]
;;;403      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
0002d0  210f              MOVS     r1,#0xf
0002d2  6b82              LDR      r2,[r0,#0x38]
0002d4  6011              STR      r1,[r2,#0]
;;;404      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
0002d6  6b82              LDR      r2,[r0,#0x38]
0002d8  6051              STR      r1,[r2,#4]
;;;405      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
0002da  21ff              MOVS     r1,#0xff
0002dc  6b82              LDR      r2,[r0,#0x38]
0002de  6091              STR      r1,[r2,#8]
;;;406      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
0002e0  210f              MOVS     r1,#0xf
0002e2  6b82              LDR      r2,[r0,#0x38]
0002e4  60d1              STR      r1,[r2,#0xc]
;;;407      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
0002e6  6b82              LDR      r2,[r0,#0x38]
0002e8  6111              STR      r1,[r2,#0x10]
;;;408      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
0002ea  6b82              LDR      r2,[r0,#0x38]
0002ec  6151              STR      r1,[r2,#0x14]
;;;409      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
0002ee  2100              MOVS     r1,#0
0002f0  6b82              LDR      r2,[r0,#0x38]
0002f2  6191              STR      r1,[r2,#0x18]
;;;410    }
0002f4  4770              BX       lr
;;;411    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;417      */
;;;418    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
0002f6  2110              MOVS     r1,#0x10
;;;419    { 
;;;420      /* Reset NAND Init structure parameters values */
;;;421      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
0002f8  6001              STR      r1,[r0,#0]
;;;422      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
0002fa  2100              MOVS     r1,#0
0002fc  6041              STR      r1,[r0,#4]
;;;423      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
0002fe  6081              STR      r1,[r0,#8]
;;;424      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000300  60c1              STR      r1,[r0,#0xc]
;;;425      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
000302  6101              STR      r1,[r0,#0x10]
;;;426      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
000304  6141              STR      r1,[r0,#0x14]
;;;427      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000306  6181              STR      r1,[r0,#0x18]
;;;428      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000308  21fc              MOVS     r1,#0xfc
00030a  69c2              LDR      r2,[r0,#0x1c]
00030c  6011              STR      r1,[r2,#0]
;;;429      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00030e  69c2              LDR      r2,[r0,#0x1c]
000310  6051              STR      r1,[r2,#4]
;;;430      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000312  69c2              LDR      r2,[r0,#0x1c]
000314  6091              STR      r1,[r2,#8]
;;;431      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000316  69c2              LDR      r2,[r0,#0x1c]
000318  60d1              STR      r1,[r2,#0xc]
;;;432      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00031a  6a02              LDR      r2,[r0,#0x20]
00031c  6011              STR      r1,[r2,#0]
;;;433      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00031e  6a02              LDR      r2,[r0,#0x20]
000320  6051              STR      r1,[r2,#4]
;;;434      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000322  6a02              LDR      r2,[r0,#0x20]
000324  6091              STR      r1,[r2,#8]
;;;435      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000326  6a02              LDR      r2,[r0,#0x20]
000328  60d1              STR      r1,[r2,#0xc]
;;;436    }
00032a  4770              BX       lr
;;;437    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;443      */
;;;444    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
00032c  2100              MOVS     r1,#0
;;;445    {
;;;446      /* Reset PCCARD Init structure parameters values */
;;;447      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
00032e  6001              STR      r1,[r0,#0]
;;;448      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000330  6041              STR      r1,[r0,#4]
;;;449      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000332  6081              STR      r1,[r0,#8]
;;;450      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000334  21fc              MOVS     r1,#0xfc
000336  68c2              LDR      r2,[r0,#0xc]
000338  6011              STR      r1,[r2,#0]
;;;451      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00033a  68c2              LDR      r2,[r0,#0xc]
00033c  6051              STR      r1,[r2,#4]
;;;452      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00033e  68c2              LDR      r2,[r0,#0xc]
000340  6091              STR      r1,[r2,#8]
;;;453      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000342  68c2              LDR      r2,[r0,#0xc]
000344  60d1              STR      r1,[r2,#0xc]
;;;454      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000346  6902              LDR      r2,[r0,#0x10]
000348  6011              STR      r1,[r2,#0]
;;;455      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00034a  6902              LDR      r2,[r0,#0x10]
00034c  6051              STR      r1,[r2,#4]
;;;456      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00034e  6902              LDR      r2,[r0,#0x10]
000350  6091              STR      r1,[r2,#8]
;;;457      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000352  6902              LDR      r2,[r0,#0x10]
000354  60d1              STR      r1,[r2,#0xc]
;;;458      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000356  6942              LDR      r2,[r0,#0x14]
000358  6011              STR      r1,[r2,#0]
;;;459      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00035a  6942              LDR      r2,[r0,#0x14]
00035c  6051              STR      r1,[r2,#4]
;;;460      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00035e  6942              LDR      r2,[r0,#0x14]
000360  6091              STR      r1,[r2,#8]
;;;461      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000362  6942              LDR      r2,[r0,#0x14]
000364  60d1              STR      r1,[r2,#0xc]
;;;462    }
000366  4770              BX       lr
;;;463    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;474      */
;;;475    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000368  b151              CBZ      r1,|L1.896|
;;;476    {
;;;477      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;483        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
00036a  0082              LSLS     r2,r0,#2
00036c  f1a242c0          SUB      r2,r2,#0x60000000
000370  6812              LDR      r2,[r2,#0]
000372  f0420301          ORR      r3,r2,#1
000376  0082              LSLS     r2,r0,#2
000378  f1a242c0          SUB      r2,r2,#0x60000000
00037c  6013              STR      r3,[r2,#0]
00037e  e009              B        |L1.916|
                  |L1.896|
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;488        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
000380  0082              LSLS     r2,r0,#2
000382  f1a242c0          SUB      r2,r2,#0x60000000
000386  6812              LDR      r2,[r2,#0]
000388  4b2a              LDR      r3,|L1.1076|
00038a  401a              ANDS     r2,r2,r3
00038c  0083              LSLS     r3,r0,#2
00038e  f1a343c0          SUB      r3,r3,#0x60000000
000392  601a              STR      r2,[r3,#0]
                  |L1.916|
;;;489      }
;;;490    }
000394  4770              BX       lr
;;;491    
                          ENDP

                  FSMC_NANDCmd PROC
;;;500      */
;;;501    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000396  b199              CBZ      r1,|L1.960|
;;;502    {
;;;503      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505      
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;509        if(FSMC_Bank == FSMC_Bank2_NAND)
000398  2810              CMP      r0,#0x10
00039a  d108              BNE      |L1.942|
;;;510        {
;;;511          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
00039c  f04f4220          MOV      r2,#0xa0000000
0003a0  6e12              LDR      r2,[r2,#0x60]
0003a2  f0420204          ORR      r2,r2,#4
0003a6  f04f4320          MOV      r3,#0xa0000000
0003aa  661a              STR      r2,[r3,#0x60]
0003ac  e01d              B        |L1.1002|
                  |L1.942|
;;;512        }
;;;513        else
;;;514        {
;;;515          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
0003ae  4a20              LDR      r2,|L1.1072|
0003b0  6812              LDR      r2,[r2,#0]
0003b2  f0420204          ORR      r2,r2,#4
0003b6  f04f4320          MOV      r3,#0xa0000000
0003ba  f8c32080          STR      r2,[r3,#0x80]
0003be  e014              B        |L1.1002|
                  |L1.960|
;;;516        }
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;521        if(FSMC_Bank == FSMC_Bank2_NAND)
0003c0  2810              CMP      r0,#0x10
0003c2  d109              BNE      |L1.984|
;;;522        {
;;;523          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
0003c4  f04f4220          MOV      r2,#0xa0000000
0003c8  6e12              LDR      r2,[r2,#0x60]
0003ca  4b1a              LDR      r3,|L1.1076|
0003cc  1edb              SUBS     r3,r3,#3
0003ce  401a              ANDS     r2,r2,r3
0003d0  f04f4320          MOV      r3,#0xa0000000
0003d4  661a              STR      r2,[r3,#0x60]
0003d6  e008              B        |L1.1002|
                  |L1.984|
;;;524        }
;;;525        else
;;;526        {
;;;527          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
0003d8  4a15              LDR      r2,|L1.1072|
0003da  6812              LDR      r2,[r2,#0]
0003dc  4b15              LDR      r3,|L1.1076|
0003de  1edb              SUBS     r3,r3,#3
0003e0  401a              ANDS     r2,r2,r3
0003e2  f04f4320          MOV      r3,#0xa0000000
0003e6  f8c32080          STR      r2,[r3,#0x80]
                  |L1.1002|
;;;528        }
;;;529      }
;;;530    }
0003ea  4770              BX       lr
;;;531    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;537      */
;;;538    void FSMC_PCCARDCmd(FunctionalState NewState)
0003ec  b148              CBZ      r0,|L1.1026|
;;;539    {
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      if (NewState != DISABLE)
;;;543      {
;;;544        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;545        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
0003ee  4910              LDR      r1,|L1.1072|
0003f0  3120              ADDS     r1,r1,#0x20
0003f2  6809              LDR      r1,[r1,#0]
0003f4  f0410104          ORR      r1,r1,#4
0003f8  f04f4220          MOV      r2,#0xa0000000
0003fc  f8c210a0          STR      r1,[r2,#0xa0]
000400  e009              B        |L1.1046|
                  |L1.1026|
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;550        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000402  490b              LDR      r1,|L1.1072|
000404  3120              ADDS     r1,r1,#0x20
000406  6809              LDR      r1,[r1,#0]
000408  4a0a              LDR      r2,|L1.1076|
00040a  1ed2              SUBS     r2,r2,#3
00040c  4011              ANDS     r1,r1,r2
00040e  f04f4220          MOV      r2,#0xa0000000
000412  f8c210a0          STR      r1,[r2,#0xa0]
                  |L1.1046|
;;;551      }
;;;552    }
000416  4770              BX       lr
;;;553    
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;563      */
;;;564    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000418  b1b9              CBZ      r1,|L1.1098|
;;;565    {
;;;566      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;567      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;568      
;;;569      if (NewState != DISABLE)
;;;570      {
;;;571        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;572        if(FSMC_Bank == FSMC_Bank2_NAND)
00041a  2810              CMP      r0,#0x10
00041c  d10c              BNE      |L1.1080|
;;;573        {
;;;574          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
00041e  f04f4220          MOV      r2,#0xa0000000
000422  6e12              LDR      r2,[r2,#0x60]
000424  f0420240          ORR      r2,r2,#0x40
000428  f04f4320          MOV      r3,#0xa0000000
00042c  661a              STR      r2,[r3,#0x60]
00042e  e01f              B        |L1.1136|
                  |L1.1072|
                          DCD      0xa0000080
                  |L1.1076|
                          DCD      0x000ffffe
                  |L1.1080|
;;;575        }
;;;576        else
;;;577        {
;;;578          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
000438  4a72              LDR      r2,|L1.1540|
00043a  6812              LDR      r2,[r2,#0]
00043c  f0420240          ORR      r2,r2,#0x40
000440  f04f4320          MOV      r3,#0xa0000000
000444  f8c32080          STR      r2,[r3,#0x80]
000448  e012              B        |L1.1136|
                  |L1.1098|
;;;579        }
;;;580      }
;;;581      else
;;;582      {
;;;583        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;584        if(FSMC_Bank == FSMC_Bank2_NAND)
00044a  2810              CMP      r0,#0x10
00044c  d108              BNE      |L1.1120|
;;;585        {
;;;586          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00044e  f04f4220          MOV      r2,#0xa0000000
000452  6e12              LDR      r2,[r2,#0x60]
000454  4b6c              LDR      r3,|L1.1544|
000456  401a              ANDS     r2,r2,r3
000458  f04f4320          MOV      r3,#0xa0000000
00045c  661a              STR      r2,[r3,#0x60]
00045e  e007              B        |L1.1136|
                  |L1.1120|
;;;587        }
;;;588        else
;;;589        {
;;;590          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000460  4a68              LDR      r2,|L1.1540|
000462  6812              LDR      r2,[r2,#0]
000464  4b68              LDR      r3,|L1.1544|
000466  401a              ANDS     r2,r2,r3
000468  f04f4320          MOV      r3,#0xa0000000
00046c  f8c32080          STR      r2,[r3,#0x80]
                  |L1.1136|
;;;591        }
;;;592      }
;;;593    }
000470  4770              BX       lr
;;;594    
                          ENDP

                  FSMC_GetECC PROC
;;;602      */
;;;603    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000472  4601              MOV      r1,r0
;;;604    {
;;;605      uint32_t eccval = 0x00000000;
000474  2000              MOVS     r0,#0
;;;606      
;;;607      if(FSMC_Bank == FSMC_Bank2_NAND)
000476  2910              CMP      r1,#0x10
000478  d103              BNE      |L1.1154|
;;;608      {
;;;609        /* Get the ECCR2 register value */
;;;610        eccval = FSMC_Bank2->ECCR2;
00047a  f04f4220          MOV      r2,#0xa0000000
00047e  6f50              LDR      r0,[r2,#0x74]
000480  e002              B        |L1.1160|
                  |L1.1154|
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Get the ECCR3 register value */
;;;615        eccval = FSMC_Bank3->ECCR3;
000482  4a60              LDR      r2,|L1.1540|
000484  3214              ADDS     r2,r2,#0x14
000486  6810              LDR      r0,[r2,#0]
                  |L1.1160|
;;;616      }
;;;617      /* Return the error correction code value */
;;;618      return(eccval);
;;;619    }
000488  4770              BX       lr
;;;620    
                          ENDP

                  FSMC_ITConfig PROC
;;;636      */
;;;637    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
00048a  b510              PUSH     {r4,lr}
;;;638    {
;;;639      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;640      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;641      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;642      
;;;643      if (NewState != DISABLE)
00048c  b1f2              CBZ      r2,|L1.1228|
;;;644      {
;;;645        /* Enable the selected FSMC_Bank2 interrupts */
;;;646        if(FSMC_Bank == FSMC_Bank2_NAND)
00048e  2810              CMP      r0,#0x10
000490  d107              BNE      |L1.1186|
;;;647        {
;;;648          FSMC_Bank2->SR2 |= FSMC_IT;
000492  f04f4320          MOV      r3,#0xa0000000
000496  6e5b              LDR      r3,[r3,#0x64]
000498  430b              ORRS     r3,r3,r1
00049a  f04f4420          MOV      r4,#0xa0000000
00049e  6663              STR      r3,[r4,#0x64]
0004a0  e032              B        |L1.1288|
                  |L1.1186|
;;;649        }
;;;650        /* Enable the selected FSMC_Bank3 interrupts */
;;;651        else if (FSMC_Bank == FSMC_Bank3_NAND)
0004a2  f5b07f80          CMP      r0,#0x100
0004a6  d108              BNE      |L1.1210|
;;;652        {
;;;653          FSMC_Bank3->SR3 |= FSMC_IT;
0004a8  4b56              LDR      r3,|L1.1540|
0004aa  1d1b              ADDS     r3,r3,#4
0004ac  681b              LDR      r3,[r3,#0]
0004ae  430b              ORRS     r3,r3,r1
0004b0  f04f4420          MOV      r4,#0xa0000000
0004b4  f8c43084          STR      r3,[r4,#0x84]
0004b8  e026              B        |L1.1288|
                  |L1.1210|
;;;654        }
;;;655        /* Enable the selected FSMC_Bank4 interrupts */
;;;656        else
;;;657        {
;;;658          FSMC_Bank4->SR4 |= FSMC_IT;    
0004ba  4b52              LDR      r3,|L1.1540|
0004bc  3324              ADDS     r3,r3,#0x24
0004be  681b              LDR      r3,[r3,#0]
0004c0  430b              ORRS     r3,r3,r1
0004c2  f04f4420          MOV      r4,#0xa0000000
0004c6  f8c430a4          STR      r3,[r4,#0xa4]
0004ca  e01d              B        |L1.1288|
                  |L1.1228|
;;;659        }
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected FSMC_Bank2 interrupts */
;;;664        if(FSMC_Bank == FSMC_Bank2_NAND)
0004cc  2810              CMP      r0,#0x10
0004ce  d107              BNE      |L1.1248|
;;;665        {
;;;666          
;;;667          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
0004d0  f04f4320          MOV      r3,#0xa0000000
0004d4  6e5b              LDR      r3,[r3,#0x64]
0004d6  438b              BICS     r3,r3,r1
0004d8  f04f4420          MOV      r4,#0xa0000000
0004dc  6663              STR      r3,[r4,#0x64]
0004de  e013              B        |L1.1288|
                  |L1.1248|
;;;668        }
;;;669        /* Disable the selected FSMC_Bank3 interrupts */
;;;670        else if (FSMC_Bank == FSMC_Bank3_NAND)
0004e0  f5b07f80          CMP      r0,#0x100
0004e4  d108              BNE      |L1.1272|
;;;671        {
;;;672          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
0004e6  4b47              LDR      r3,|L1.1540|
0004e8  1d1b              ADDS     r3,r3,#4
0004ea  681b              LDR      r3,[r3,#0]
0004ec  438b              BICS     r3,r3,r1
0004ee  f04f4420          MOV      r4,#0xa0000000
0004f2  f8c43084          STR      r3,[r4,#0x84]
0004f6  e007              B        |L1.1288|
                  |L1.1272|
;;;673        }
;;;674        /* Disable the selected FSMC_Bank4 interrupts */
;;;675        else
;;;676        {
;;;677          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
0004f8  4b42              LDR      r3,|L1.1540|
0004fa  3324              ADDS     r3,r3,#0x24
0004fc  681b              LDR      r3,[r3,#0]
0004fe  438b              BICS     r3,r3,r1
000500  f04f4420          MOV      r4,#0xa0000000
000504  f8c430a4          STR      r3,[r4,#0xa4]
                  |L1.1288|
;;;678        }
;;;679      }
;;;680    }
000508  bd10              POP      {r4,pc}
;;;681    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;696      */
;;;697    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
00050a  b510              PUSH     {r4,lr}
;;;698    {
00050c  4602              MOV      r2,r0
;;;699      FlagStatus bitstatus = RESET;
00050e  2000              MOVS     r0,#0
;;;700      uint32_t tmpsr = 0x00000000;
000510  2300              MOVS     r3,#0
;;;701      
;;;702      /* Check the parameters */
;;;703      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;704      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;705      
;;;706      if(FSMC_Bank == FSMC_Bank2_NAND)
000512  2a10              CMP      r2,#0x10
000514  d103              BNE      |L1.1310|
;;;707      {
;;;708        tmpsr = FSMC_Bank2->SR2;
000516  f04f4420          MOV      r4,#0xa0000000
00051a  6e63              LDR      r3,[r4,#0x64]
00051c  e009              B        |L1.1330|
                  |L1.1310|
;;;709      }  
;;;710      else if(FSMC_Bank == FSMC_Bank3_NAND)
00051e  f5b27f80          CMP      r2,#0x100
000522  d103              BNE      |L1.1324|
;;;711      {
;;;712        tmpsr = FSMC_Bank3->SR3;
000524  4c37              LDR      r4,|L1.1540|
000526  1d24              ADDS     r4,r4,#4
000528  6823              LDR      r3,[r4,#0]
00052a  e002              B        |L1.1330|
                  |L1.1324|
;;;713      }
;;;714      /* FSMC_Bank4_PCCARD*/
;;;715      else
;;;716      {
;;;717        tmpsr = FSMC_Bank4->SR4;
00052c  4c35              LDR      r4,|L1.1540|
00052e  3424              ADDS     r4,r4,#0x24
000530  6823              LDR      r3,[r4,#0]
                  |L1.1330|
;;;718      } 
;;;719      
;;;720      /* Get the flag status */
;;;721      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000532  ea030401          AND      r4,r3,r1
000536  b10c              CBZ      r4,|L1.1340|
;;;722      {
;;;723        bitstatus = SET;
000538  2001              MOVS     r0,#1
00053a  e000              B        |L1.1342|
                  |L1.1340|
;;;724      }
;;;725      else
;;;726      {
;;;727        bitstatus = RESET;
00053c  2000              MOVS     r0,#0
                  |L1.1342|
;;;728      }
;;;729      /* Return the flag status */
;;;730      return bitstatus;
;;;731    }
00053e  bd10              POP      {r4,pc}
;;;732    
                          ENDP

                  FSMC_ClearFlag PROC
;;;746      */
;;;747    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000540  2810              CMP      r0,#0x10
;;;748    {
;;;749     /* Check the parameters */
;;;750      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;751      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;752        
;;;753      if(FSMC_Bank == FSMC_Bank2_NAND)
000542  d107              BNE      |L1.1364|
;;;754      {
;;;755        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
000544  f04f4220          MOV      r2,#0xa0000000
000548  6e52              LDR      r2,[r2,#0x64]
00054a  438a              BICS     r2,r2,r1
00054c  f04f4320          MOV      r3,#0xa0000000
000550  665a              STR      r2,[r3,#0x64]
000552  e013              B        |L1.1404|
                  |L1.1364|
;;;756      }  
;;;757      else if(FSMC_Bank == FSMC_Bank3_NAND)
000554  f5b07f80          CMP      r0,#0x100
000558  d108              BNE      |L1.1388|
;;;758      {
;;;759        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
00055a  4a2a              LDR      r2,|L1.1540|
00055c  1d12              ADDS     r2,r2,#4
00055e  6812              LDR      r2,[r2,#0]
000560  438a              BICS     r2,r2,r1
000562  f04f4320          MOV      r3,#0xa0000000
000566  f8c32084          STR      r2,[r3,#0x84]
00056a  e007              B        |L1.1404|
                  |L1.1388|
;;;760      }
;;;761      /* FSMC_Bank4_PCCARD*/
;;;762      else
;;;763      {
;;;764        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00056c  4a25              LDR      r2,|L1.1540|
00056e  3224              ADDS     r2,r2,#0x24
000570  6812              LDR      r2,[r2,#0]
000572  438a              BICS     r2,r2,r1
000574  f04f4320          MOV      r3,#0xa0000000
000578  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1404|
;;;765      }
;;;766    }
00057c  4770              BX       lr
;;;767    
                          ENDP

                  FSMC_GetITStatus PROC
;;;781      */
;;;782    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00057e  b570              PUSH     {r4-r6,lr}
;;;783    {
000580  4602              MOV      r2,r0
;;;784      ITStatus bitstatus = RESET;
000582  2000              MOVS     r0,#0
;;;785      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
000584  2300              MOVS     r3,#0
000586  2400              MOVS     r4,#0
000588  2500              MOVS     r5,#0
;;;786      
;;;787      /* Check the parameters */
;;;788      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;789      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;790      
;;;791      if(FSMC_Bank == FSMC_Bank2_NAND)
00058a  2a10              CMP      r2,#0x10
00058c  d103              BNE      |L1.1430|
;;;792      {
;;;793        tmpsr = FSMC_Bank2->SR2;
00058e  f04f4620          MOV      r6,#0xa0000000
000592  6e73              LDR      r3,[r6,#0x64]
000594  e009              B        |L1.1450|
                  |L1.1430|
;;;794      }  
;;;795      else if(FSMC_Bank == FSMC_Bank3_NAND)
000596  f5b27f80          CMP      r2,#0x100
00059a  d103              BNE      |L1.1444|
;;;796      {
;;;797        tmpsr = FSMC_Bank3->SR3;
00059c  4e19              LDR      r6,|L1.1540|
00059e  1d36              ADDS     r6,r6,#4
0005a0  6833              LDR      r3,[r6,#0]
0005a2  e002              B        |L1.1450|
                  |L1.1444|
;;;798      }
;;;799      /* FSMC_Bank4_PCCARD*/
;;;800      else
;;;801      {
;;;802        tmpsr = FSMC_Bank4->SR4;
0005a4  4e17              LDR      r6,|L1.1540|
0005a6  3624              ADDS     r6,r6,#0x24
0005a8  6833              LDR      r3,[r6,#0]
                  |L1.1450|
;;;803      } 
;;;804      
;;;805      itstatus = tmpsr & FSMC_IT;
0005aa  ea030401          AND      r4,r3,r1
;;;806      
;;;807      itenable = tmpsr & (FSMC_IT >> 3);
0005ae  ea0305d1          AND      r5,r3,r1,LSR #3
;;;808      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
0005b2  b114              CBZ      r4,|L1.1466|
0005b4  b10d              CBZ      r5,|L1.1466|
;;;809      {
;;;810        bitstatus = SET;
0005b6  2001              MOVS     r0,#1
0005b8  e000              B        |L1.1468|
                  |L1.1466|
;;;811      }
;;;812      else
;;;813      {
;;;814        bitstatus = RESET;
0005ba  2000              MOVS     r0,#0
                  |L1.1468|
;;;815      }
;;;816      return bitstatus; 
;;;817    }
0005bc  bd70              POP      {r4-r6,pc}
;;;818    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;832      */
;;;833    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
0005be  2810              CMP      r0,#0x10
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;837      assert_param(IS_FSMC_IT(FSMC_IT));
;;;838        
;;;839      if(FSMC_Bank == FSMC_Bank2_NAND)
0005c0  d108              BNE      |L1.1492|
;;;840      {
;;;841        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
0005c2  f04f4220          MOV      r2,#0xa0000000
0005c6  6e52              LDR      r2,[r2,#0x64]
0005c8  ea2202d1          BIC      r2,r2,r1,LSR #3
0005cc  f04f4320          MOV      r3,#0xa0000000
0005d0  665a              STR      r2,[r3,#0x64]
0005d2  e015              B        |L1.1536|
                  |L1.1492|
;;;842      }  
;;;843      else if(FSMC_Bank == FSMC_Bank3_NAND)
0005d4  f5b07f80          CMP      r0,#0x100
0005d8  d109              BNE      |L1.1518|
;;;844      {
;;;845        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
0005da  4a0a              LDR      r2,|L1.1540|
0005dc  1d12              ADDS     r2,r2,#4
0005de  6812              LDR      r2,[r2,#0]
0005e0  ea2202d1          BIC      r2,r2,r1,LSR #3
0005e4  f04f4320          MOV      r3,#0xa0000000
0005e8  f8c32084          STR      r2,[r3,#0x84]
0005ec  e008              B        |L1.1536|
                  |L1.1518|
;;;846      }
;;;847      /* FSMC_Bank4_PCCARD*/
;;;848      else
;;;849      {
;;;850        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
0005ee  4a05              LDR      r2,|L1.1540|
0005f0  3224              ADDS     r2,r2,#0x24
0005f2  6812              LDR      r2,[r2,#0]
0005f4  ea2202d1          BIC      r2,r2,r1,LSR #3
0005f8  f04f4320          MOV      r3,#0xa0000000
0005fc  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1536|
;;;851      }
;;;852    }
000600  4770              BX       lr
;;;853    
                          ENDP

000602  0000              DCW      0x0000
                  |L1.1540|
                          DCD      0xa0000080
                  |L1.1544|
                          DCD      0x000fffbf
