; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\diskio.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_·­Ò³\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\diskio.crf user\diskio.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;24     
;;;25     DSTATUS disk_initialize (
000000  4601              MOV      r1,r0
;;;26     	BYTE drv				/* Physical drive nmuber (0..) */
;;;27     )
;;;28     {
;;;29     	return 0;
000002  2000              MOVS     r0,#0
;;;30     }
000004  4770              BX       lr
;;;31     
                          ENDP

                  disk_status PROC
;;;36     
;;;37     DSTATUS disk_status (
000006  4601              MOV      r1,r0
;;;38     	BYTE drv		/* Physical drive nmuber (0..) */
;;;39     )
;;;40     {	
;;;41     	return 0;
000008  2000              MOVS     r0,#0
;;;42     }
00000a  4770              BX       lr
;;;43     
                          ENDP

                  disk_read PROC
;;;48     
;;;49     DRESULT disk_read (
00000c  e92d41f0          PUSH     {r4-r8,lr}
;;;50     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;51     	BYTE *buff,		/* Data buffer to store read data */
;;;52     	DWORD sector,	/* Sector address (LBA) */
;;;53     	BYTE count		/* Number of sectors to read (1..255) */
;;;54     )
;;;55     {	 
000010  4607              MOV      r7,r0
000012  460c              MOV      r4,r1
000014  4615              MOV      r5,r2
000016  461e              MOV      r6,r3
;;;56     	if(count==1)
000018  2e01              CMP      r6,#1
00001a  d104              BNE      |L1.38|
;;;57         {
;;;58               SD_ReadBlock((u32 *)(&buff[0]),sector << 9 ,SECTOR_SIZE);
00001c  0269              LSLS     r1,r5,#9
00001e  025a              LSLS     r2,r3,#9
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SD_ReadBlock
                  |L1.38|
;;;59              
;;;60     	}
;;;61     	return RES_OK;
000026  2000              MOVS     r0,#0
;;;62     }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP

                  disk_write PROC
;;;69     #if _READONLY == 0
;;;70     DRESULT disk_write (
00002c  e92d41f0          PUSH     {r4-r8,lr}
;;;71     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;72     	const BYTE *buff,	/* Data to be written */
;;;73     	DWORD sector,		/* Sector address (LBA) */
;;;74     	BYTE count			/* Number of sectors to write (1..255) */
;;;75     )
;;;76     {
000030  4607              MOV      r7,r0
000032  460c              MOV      r4,r1
000034  4615              MOV      r5,r2
000036  461e              MOV      r6,r3
;;;77     	if(count==1)
000038  2e01              CMP      r6,#1
00003a  d104              BNE      |L1.70|
;;;78         {     
;;;79               SD_WriteBlock((u32 *)(&buff[0]),sector << 9 ,SECTOR_SIZE);
00003c  0269              LSLS     r1,r5,#9
00003e  025a              LSLS     r2,r3,#9
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       SD_WriteBlock
                  |L1.70|
;;;80     	}         
;;;81       	return RES_OK;
000046  2000              MOVS     r0,#0
;;;82     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;83     #endif /* _READONLY */
                          ENDP

                  disk_ioctl PROC
;;;89     
;;;90     DRESULT disk_ioctl (
00004c  4603              MOV      r3,r0
;;;91     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;92     	BYTE ctrl,		/* Control code */
;;;93     	void *buff		/* Buffer to send/receive control data */
;;;94     )
;;;95     {
;;;96     	return RES_OK;
00004e  2000              MOVS     r0,#0
;;;97     }
000050  4770              BX       lr
;;;98     
                          ENDP

                  get_fattime PROC
;;;99     DWORD get_fattime(void){
000052  2000              MOVS     r0,#0
;;;100    	return 0;
;;;101    }
000054  4770              BX       lr
;;;102    
                          ENDP

