; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\sd_card.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\sd_card.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_翻页\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\sd_card.crf user\SD_Card.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  in_func PROC
;;;58     ****************************************************************************/
;;;59     UINT in_func( 
000000  b5f8              PUSH     {r3-r7,lr}
;;;60        JDEC* jd,          /* Decoder object */ 
;;;61        BYTE* buff,        /* Pointer to the read buffer (NULL:skip) */ 
;;;62         UINT nd           /* Number of bytes to read/skip from input stream */ 
;;;63     ) 
;;;64     { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;65         UINT rb; 
;;;66         FIL *fil = (FIL*)jd->device;    /* Input stream of this session */   
000008  6fa7              LDR      r7,[r4,#0x78]
;;;67         if (buff)     					/* Read nd bytes from the input strem */ 
00000a  b13d              CBZ      r5,|L1.28|
;;;68         { 
;;;69             f_read(fil, buff, nd, &rb);		
00000c  466b              MOV      r3,sp
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       f_read
;;;70             return rb;       		    /* Returns number of bytes could be read */ 
000018  9800              LDR      r0,[sp,#0]
                  |L1.26|
;;;71         }  
;;;72         else  
;;;73         { 	
;;;74             return (f_lseek(fil, f_tell(fil) + nd) == FR_OK) ? nd : 0;/* Skip nd bytes on the input stream */ 
;;;75         } 
;;;76     } 
00001a  bdf8              POP      {r3-r7,pc}
                  |L1.28|
00001c  68b8              LDR      r0,[r7,#8]            ;74
00001e  1981              ADDS     r1,r0,r6              ;74
000020  4638              MOV      r0,r7                 ;74
000022  f7fffffe          BL       f_lseek
000026  b908              CBNZ     r0,|L1.44|
000028  4630              MOV      r0,r6                 ;74
00002a  e7f6              B        |L1.26|
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;74
00002e  e7f4              B        |L1.26|
;;;77     
                          ENDP

                  STM32_disp_blt PROC
;;;88     // 在屏幕上显示图片 
;;;89     void STM32_disp_blt (
000030  e92d43f0          PUSH     {r4-r9,lr}
;;;90          int left,        /* Left end (-32768 to 32767) */ 
;;;91          int right,       /* Right end (-32768 to 32767, >=left) */ 
;;;92          int top,         /* Top end (-32768 to 32767) */ 
;;;93          int bottom,      /* Bottom end (-32768 to 32767, >=right) */ 
;;;94          const uint16_t *pat    /* Pattern data */ 
;;;95     ) 
;;;96     { 
000034  9d07              LDR      r5,[sp,#0x1c]
;;;97     	int yc, xc, xl, xs;
;;;98     	if (left > right || top > bottom) return; 	// Check varidity 
000036  4288              CMP      r0,r1
000038  dc01              BGT      |L1.62|
00003a  429a              CMP      r2,r3
00003c  dd01              BLE      |L1.66|
                  |L1.62|
;;;99     	if (left > MaskR || right < MaskL  || top > MaskB || bottom < MaskT) return;	// Check if in active area 
;;;100    
;;;101    	yc = bottom - top + 1;			// Vertical size 
;;;102    	xc = right - left + 1; xs = 0;	//Horizontal size and skip 
;;;103    
;;;104    	if (top < MaskT) {		// Clip top of source image if it is out of active area 
;;;105    		pat += xc * (MaskT - top);
;;;106    		yc -= MaskT - top;
;;;107    		top = MaskT;
;;;108    	}
;;;109    	if (bottom > MaskB) {	// Clip bottom of source image if it is out of active area 
;;;110    		yc -= bottom - MaskB;
;;;111    		bottom = MaskB;
;;;112    	}
;;;113    	if (left < MaskL) {		// Clip left of source image if it is out of active area 
;;;114    		pat += MaskL - left;
;;;115    		xc -= MaskL - left;
;;;116    		xs += MaskL - left;
;;;117    		left = MaskL;
;;;118    	}
;;;119    	if (right > MaskR) {	 // Clip right of source image it is out of active area 
;;;120    		xc -= right - MaskR;
;;;121    		xs += right - MaskR;
;;;122    		right = MaskR;
;;;123    	}
;;;124    
;;;125    	/*  ???????? */
;;;126    	*(__IO uint16_t *) (Bank1_LCD_C)= 0x002a;	
;;;127    	*(__IO uint16_t *) (Bank1_LCD_D)= left>>8;
;;;128    	*(__IO uint16_t *) (Bank1_LCD_D)= left&0xff;
;;;129    	*(__IO uint16_t *) (Bank1_LCD_D)= right>>8;	
;;;130    	*(__IO uint16_t *) (Bank1_LCD_D)= right&0xff;
;;;131    
;;;132    
;;;133    	*(__IO uint16_t *) (Bank1_LCD_C)= 0x002b;	
;;;134    	*(__IO uint16_t *) (Bank1_LCD_D)= top>>8;
;;;135    	*(__IO uint16_t *) (Bank1_LCD_D)= top&0xff;
;;;136    	*(__IO uint16_t *) (Bank1_LCD_D)= bottom>>8;
;;;137    	*(__IO uint16_t *) (Bank1_LCD_D)= bottom&0xff;
;;;138    
;;;139    	*(__IO uint16_t *) (Bank1_LCD_C)= 0x002C;
;;;140    
;;;141    	
;;;142    	do {	/* Send image data */
;;;143    		xl = xc;
;;;144    		do {
;;;145    			*(__IO uint16_t *) (Bank1_LCD_D)=*pat;			//????
;;;146    			pat++;
;;;147    		} while (--xl);	
;;;148    		//pat += xs;
;;;149    	} while (--yc);
;;;150    }
00003e  e8bd83f0          POP      {r4-r9,pc}
                  |L1.66|
000042  f8df8364          LDR      r8,|L1.936|
000046  f8d88000          LDR      r8,[r8,#0]            ;99  ; MaskR
00004a  4540              CMP      r0,r8                 ;99
00004c  dc11              BGT      |L1.114|
00004e  f8df835c          LDR      r8,|L1.940|
000052  f8d88000          LDR      r8,[r8,#0]            ;99  ; MaskL
000056  4541              CMP      r1,r8                 ;99
000058  db0b              BLT      |L1.114|
00005a  f8df8354          LDR      r8,|L1.944|
00005e  f8d88000          LDR      r8,[r8,#0]            ;99  ; MaskB
000062  4542              CMP      r2,r8                 ;99
000064  dc05              BGT      |L1.114|
000066  f8df834c          LDR      r8,|L1.948|
00006a  f8d88000          LDR      r8,[r8,#0]            ;99  ; MaskT
00006e  4543              CMP      r3,r8                 ;99
000070  da00              BGE      |L1.116|
                  |L1.114|
000072  e7e4              B        |L1.62|
                  |L1.116|
000074  eba30802          SUB      r8,r3,r2              ;101
000078  f1080601          ADD      r6,r8,#1              ;101
00007c  eba10800          SUB      r8,r1,r0              ;102
000080  f1080401          ADD      r4,r8,#1              ;102
000084  2700              MOVS     r7,#0                 ;102
000086  f8df832c          LDR      r8,|L1.948|
00008a  f8d88000          LDR      r8,[r8,#0]            ;104  ; MaskT
00008e  4542              CMP      r2,r8                 ;104
000090  da15              BGE      |L1.190|
000092  f8df8320          LDR      r8,|L1.948|
000096  f8d88000          LDR      r8,[r8,#0]            ;105  ; MaskT
00009a  eba80802          SUB      r8,r8,r2              ;105
00009e  fb08f804          MUL      r8,r8,r4              ;105
0000a2  eb050548          ADD      r5,r5,r8,LSL #1       ;105
0000a6  f8df830c          LDR      r8,|L1.948|
0000aa  f8d88000          LDR      r8,[r8,#0]            ;106  ; MaskT
0000ae  eba80802          SUB      r8,r8,r2              ;106
0000b2  eba60608          SUB      r6,r6,r8              ;106
0000b6  f8df82fc          LDR      r8,|L1.948|
0000ba  f8d82000          LDR      r2,[r8,#0]            ;107  ; MaskT
                  |L1.190|
0000be  f8df82f0          LDR      r8,|L1.944|
0000c2  f8d88000          LDR      r8,[r8,#0]            ;109  ; MaskB
0000c6  4543              CMP      r3,r8                 ;109
0000c8  dd0b              BLE      |L1.226|
0000ca  f8df82e4          LDR      r8,|L1.944|
0000ce  f8d88000          LDR      r8,[r8,#0]            ;110  ; MaskB
0000d2  eba30808          SUB      r8,r3,r8              ;110
0000d6  eba60608          SUB      r6,r6,r8              ;110
0000da  f8df82d4          LDR      r8,|L1.944|
0000de  f8d83000          LDR      r3,[r8,#0]            ;111  ; MaskB
                  |L1.226|
0000e2  f8df82c8          LDR      r8,|L1.940|
0000e6  f8d88000          LDR      r8,[r8,#0]            ;113  ; MaskL
0000ea  4540              CMP      r0,r8                 ;113
0000ec  da1a              BGE      |L1.292|
0000ee  f8df82bc          LDR      r8,|L1.940|
0000f2  f8d88000          LDR      r8,[r8,#0]            ;114  ; MaskL
0000f6  eba80800          SUB      r8,r8,r0              ;114
0000fa  eb050548          ADD      r5,r5,r8,LSL #1       ;114
0000fe  f8df82ac          LDR      r8,|L1.940|
000102  f8d88000          LDR      r8,[r8,#0]            ;115  ; MaskL
000106  eba80800          SUB      r8,r8,r0              ;115
00010a  eba40408          SUB      r4,r4,r8              ;115
00010e  f8df829c          LDR      r8,|L1.940|
000112  f8d88000          LDR      r8,[r8,#0]            ;116  ; MaskL
000116  eba80800          SUB      r8,r8,r0              ;116
00011a  4447              ADD      r7,r7,r8              ;116
00011c  f8df828c          LDR      r8,|L1.940|
000120  f8d80000          LDR      r0,[r8,#0]            ;117  ; MaskL
                  |L1.292|
000124  f8df8280          LDR      r8,|L1.936|
000128  f8d88000          LDR      r8,[r8,#0]            ;119  ; MaskR
00012c  4541              CMP      r1,r8                 ;119
00012e  dd12              BLE      |L1.342|
000130  f8df8274          LDR      r8,|L1.936|
000134  f8d88000          LDR      r8,[r8,#0]            ;120  ; MaskR
000138  eba10808          SUB      r8,r1,r8              ;120
00013c  eba40408          SUB      r4,r4,r8              ;120
000140  f8df8264          LDR      r8,|L1.936|
000144  f8d88000          LDR      r8,[r8,#0]            ;121  ; MaskR
000148  eba10808          SUB      r8,r1,r8              ;121
00014c  4447              ADD      r7,r7,r8              ;121
00014e  f8df8258          LDR      r8,|L1.936|
000152  f8d81000          LDR      r1,[r8,#0]            ;122  ; MaskR
                  |L1.342|
000156  f04f082a          MOV      r8,#0x2a              ;126
00015a  f04f49c0          MOV      r9,#0x60000000        ;126
00015e  f8a98000          STRH     r8,[r9,#0]            ;126
000162  f3c0280f          UBFX     r8,r0,#8,#16          ;127
000166  f8df9250          LDR      r9,|L1.952|
00016a  f8a98000          STRH     r8,[r9,#0]            ;127
00016e  f00008ff          AND      r8,r0,#0xff           ;128
000172  f8a98000          STRH     r8,[r9,#0]            ;128
000176  f3c1280f          UBFX     r8,r1,#8,#16          ;129
00017a  f8a98000          STRH     r8,[r9,#0]            ;129
00017e  f00108ff          AND      r8,r1,#0xff           ;130
000182  f8a98000          STRH     r8,[r9,#0]            ;130
000186  f04f082b          MOV      r8,#0x2b              ;133
00018a  f04f49c0          MOV      r9,#0x60000000        ;133
00018e  f8a98000          STRH     r8,[r9,#0]            ;133
000192  f3c2280f          UBFX     r8,r2,#8,#16          ;134
000196  f8df9220          LDR      r9,|L1.952|
00019a  f8a98000          STRH     r8,[r9,#0]            ;134
00019e  f00208ff          AND      r8,r2,#0xff           ;135
0001a2  f8a98000          STRH     r8,[r9,#0]            ;135
0001a6  f3c3280f          UBFX     r8,r3,#8,#16          ;136
0001aa  f8a98000          STRH     r8,[r9,#0]            ;136
0001ae  f00308ff          AND      r8,r3,#0xff           ;137
0001b2  f8a98000          STRH     r8,[r9,#0]            ;137
0001b6  f04f082c          MOV      r8,#0x2c              ;139
0001ba  f04f49c0          MOV      r9,#0x60000000        ;139
0001be  f8a98000          STRH     r8,[r9,#0]            ;139
0001c2  bf00              NOP                            ;142
                  |L1.452|
0001c4  46a4              MOV      r12,r4                ;143
0001c6  bf00              NOP                            ;144
                  |L1.456|
0001c8  f8b58000          LDRH     r8,[r5,#0]            ;145
0001cc  f8df91e8          LDR      r9,|L1.952|
0001d0  f8a98000          STRH     r8,[r9,#0]            ;145
0001d4  1cad              ADDS     r5,r5,#2              ;146
0001d6  f1ac0801          SUB      r8,r12,#1             ;147
0001da  ea5f0c08          MOVS     r12,r8                ;147
0001de  d1f3              BNE      |L1.456|
0001e0  f1a60801          SUB      r8,r6,#1              ;149
0001e4  ea5f0608          MOVS     r6,r8                 ;149
0001e8  d1ec              BNE      |L1.452|
0001ea  bf00              NOP      
0001ec  e727              B        |L1.62|
;;;151    /****************************************************************************
                          ENDP

                  out_func PROC
;;;158    ****************************************************************************/
;;;159    UINT out_func (JDEC* jd, void* bitmap, JRECT* rect)
0001ee  b5f8              PUSH     {r3-r7,lr}
;;;160    {
0001f0  4605              MOV      r5,r0
0001f2  460e              MOV      r6,r1
0001f4  4614              MOV      r4,r2
;;;161      jd=jd;
0001f6  bf00              NOP      
;;;162    	STM32_disp_blt(rect->left, rect->right, rect->top, rect->bottom, (uint16_t*)bitmap); 
0001f8  9600              STR      r6,[sp,#0]
0001fa  88e3              LDRH     r3,[r4,#6]
0001fc  88a2              LDRH     r2,[r4,#4]
0001fe  8861              LDRH     r1,[r4,#2]
000200  8820              LDRH     r0,[r4,#0]
000202  f7fffffe          BL       STM32_disp_blt
;;;163    	return 1;    /* Continue to decompress */
000206  2001              MOVS     r0,#1
;;;164    }
000208  bdf8              POP      {r3-r7,pc}
;;;165    
                          ENDP

                  Disp_Mask PROC
;;;273    
;;;274    void Disp_Mask (
00020a  b510              PUSH     {r4,lr}
;;;275    	int left,		/* Left end of active window (0 to DISP_XS-1) */
;;;276    	int right,		/* Right end of active window (0 to DISP_XS-1, >=left) */
;;;277    	int top,		/* Top end of active window (0 to DISP_YS-1) */
;;;278    	int bottom		/* Bottom end of active window (0 to DISP_YS-1, >=top) */
;;;279    )
;;;280    {
;;;281    	{
;;;282    		MaskL = left;
00020c  4c67              LDR      r4,|L1.940|
00020e  6020              STR      r0,[r4,#0]  ; MaskL
;;;283    		MaskR = right;
000210  4c65              LDR      r4,|L1.936|
000212  6021              STR      r1,[r4,#0]  ; MaskR
;;;284    		MaskT = top;
000214  4c67              LDR      r4,|L1.948|
000216  6022              STR      r2,[r4,#0]  ; MaskT
;;;285    		MaskB = bottom;
000218  4c65              LDR      r4,|L1.944|
00021a  6023              STR      r3,[r4,#0]  ; MaskB
;;;286    	}
;;;287    }
00021c  bd10              POP      {r4,pc}
                          ENDP

                  OutPutFile PROC
;;;173    ****************************************************************************/ 
;;;174    void OutPutFile(char ImageName)
00021e  e92d41f0          PUSH     {r4-r8,lr}
;;;175    { 
000222  b09c              SUB      sp,sp,#0x70
000224  4605              MOV      r5,r0
;;;176      u8 scale;
;;;177      FILINFO finfo;
;;;178      DIR dirs;
;;;179      JRESULT res1;      /* Result code of TJpgDec API */
;;;180      
;;;181      char path[50]={""}; 	  						 //目录名为空，表示是根目录
000226  2134              MOVS     r1,#0x34
000228  a802              ADD      r0,sp,#8
00022a  f7fffffe          BL       __aeabi_memclr4
;;;182      char *result1, *result2; 
;;;183    	
;;;184      /*开启长文件名功能时， 要预先初始化文件名缓冲区的长度 */
;;;185      #if _USE_LFN
;;;186        static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1];
;;;187        finfo.lfname = lfn;
;;;188        finfo.lfsize = sizeof(lfn);
;;;189      #endif
;;;190      disk_initialize(0);						     //fatfs可以管理多个介质的分区， 所以把物理存储介质SD卡标示为0区，相当于磁盘编号
00022e  2000              MOVS     r0,#0
000230  f7fffffe          BL       disk_initialize
;;;191      f_mount(0, &fs);							     //将文件系统设置到0区 
000234  4961              LDR      r1,|L1.956|
000236  2000              MOVS     r0,#0
000238  f7fffffe          BL       f_mount
;;;192      
;;;193    	if (f_opendir(&dirs, path) == FR_OK)            //读取该磁盘的根目录        
00023c  a902              ADD      r1,sp,#8
00023e  a80f              ADD      r0,sp,#0x3c
000240  f7fffffe          BL       f_opendir
000244  2800              CMP      r0,#0
000246  d16f              BNE      |L1.808|
;;;194      {
;;;195        while (f_readdir(&dirs, &finfo) == FR_OK)  	 //循环依次读取文件名
000248  e067              B        |L1.794|
                  |L1.586|
;;;196        {	 
;;;197          if (finfo.fattrib & AM_ARC) 			     		//判断文件属性是否为存档型	 TXT文件一般都为存档型
00024a  f89d0060          LDRB     r0,[sp,#0x60]
00024e  f0000020          AND      r0,r0,#0x20
000252  2800              CMP      r0,#0
000254  d061              BEQ      |L1.794|
;;;198          {
;;;199    				if(!finfo.fname[0])	 break;    		     		//如果是文件名为空表示到目录的末尾。退出
000256  f89d0061          LDRB     r0,[sp,#0x61]
00025a  b900              CBNZ     r0,|L1.606|
00025c  e063              B        |L1.806|
                  |L1.606|
;;;200    				
;;;201    				if(finfo.fname[0] == ImageName)
00025e  f89d0061          LDRB     r0,[sp,#0x61]
000262  42a8              CMP      r0,r5
000264  d153              BNE      |L1.782|
;;;202    				{  
;;;203    					if(ImageName == '1')
000266  2d31              CMP      r5,#0x31
000268  d108              BNE      |L1.636|
;;;204    						Disp_Mask(0, 480, 0, 272);		 //设置绘图区域
00026a  f44f7388          MOV      r3,#0x110
00026e  2200              MOVS     r2,#0
000270  f44f71f0          MOV      r1,#0x1e0
000274  4610              MOV      r0,r2
000276  f7fffffe          BL       Disp_Mask
00027a  e009              B        |L1.656|
                  |L1.636|
;;;205    					else if(ImageName == '2')
00027c  2d32              CMP      r5,#0x32
00027e  d107              BNE      |L1.656|
;;;206    						Disp_Mask(0, 480, 0, 272);
000280  f44f7388          MOV      r3,#0x110
000284  2200              MOVS     r2,#0
000286  f44f71f0          MOV      r1,#0x1e0
00028a  4610              MOV      r0,r2
00028c  f7fffffe          BL       Disp_Mask
                  |L1.656|
;;;207    //					else if(ImageName == '2')
;;;208    //						Disp_Mask(219, 249, 44, 80);
;;;209    //					else if(ImageName == '3')
;;;210    //						Disp_Mask(321, 351, 43, 79);
;;;211    //					else if(ImageName == '4')
;;;212    //						Disp_Mask(424, 454, 44, 80);
;;;213    //					else if(ImageName == '5')
;;;214    //						Disp_Mask(0, 480, 0, 272);
;;;215    					
;;;216    					result1=strstr(finfo.fname,".JPG");								 //判断是否是bin（小写）后缀的文件名
000290  a14b              ADR      r1,|L1.960|
000292  f10d0061          ADD      r0,sp,#0x61
000296  f7fffffe          BL       strstr
00029a  4607              MOV      r7,r0
;;;217    					result2=strstr(finfo.fname,".jpg");	     						 //比较后缀是否bin（大写）后缀的文件名				
00029c  a14a              ADR      r1,|L1.968|
00029e  f10d0061          ADD      r0,sp,#0x61
0002a2  f7fffffe          BL       strstr
0002a6  4606              MOV      r6,r0
;;;218    				
;;;219    					if(result1!=NULL||result2!=NULL)									//是的话就输出文件的内容	
0002a8  b907              CBNZ     r7,|L1.684|
0002aa  b386              CBZ      r6,|L1.782|
                  |L1.684|
;;;220    					{	 								  								  		 			  
;;;221    						res = f_open(&fsrc, finfo.fname, FA_OPEN_EXISTING | FA_READ); //以读的方式打开文件
0002ac  2201              MOVS     r2,#1
0002ae  f10d0161          ADD      r1,sp,#0x61
0002b2  4847              LDR      r0,|L1.976|
0002b4  f7fffffe          BL       f_open
0002b8  4946              LDR      r1,|L1.980|
0002ba  7008              STRB     r0,[r1,#0]
;;;222    					
;;;223    						/* 准备解压 */
;;;224    						res1 = jd_prepare(&jdec, in_func, buffer, 8192, &fsrc);
0002bc  4844              LDR      r0,|L1.976|
0002be  f44f5300          MOV      r3,#0x2000
0002c2  4a45              LDR      r2,|L1.984|
0002c4  f2af21c7          ADR      r1,in_func + 1
0002c8  9000              STR      r0,[sp,#0]
0002ca  4844              LDR      r0,|L1.988|
0002cc  f7fffffe          BL       jd_prepare
0002d0  4680              MOV      r8,r0
;;;225    
;;;226    						if(res1 == JDR_OK)
0002d2  f1b80f00          CMP      r8,#0
0002d6  d11a              BNE      |L1.782|
;;;227    						{
;;;228    							/* 确定缩放因子 */
;;;229    							for (scale = 0; scale < 3; scale++) 
0002d8  2400              MOVS     r4,#0
0002da  e00e              B        |L1.762|
                  |L1.732|
;;;230    							{
;;;231    								if (((jdec.width >> scale) <= 480) && ((jdec.height >> scale) <= 272))break;
0002dc  483f              LDR      r0,|L1.988|
0002de  69c0              LDR      r0,[r0,#0x1c]  ; jdec
0002e0  40e0              LSRS     r0,r0,r4
0002e2  f5b07ff0          CMP      r0,#0x1e0
0002e6  d806              BHI      |L1.758|
0002e8  483c              LDR      r0,|L1.988|
0002ea  6a00              LDR      r0,[r0,#0x20]  ; jdec
0002ec  40e0              LSRS     r0,r0,r4
0002ee  f5b07f88          CMP      r0,#0x110
0002f2  d800              BHI      |L1.758|
0002f4  e003              B        |L1.766|
                  |L1.758|
0002f6  1c60              ADDS     r0,r4,#1              ;229
0002f8  b2c4              UXTB     r4,r0                 ;229
                  |L1.762|
0002fa  2c03              CMP      r4,#3                 ;229
0002fc  dbee              BLT      |L1.732|
                  |L1.766|
0002fe  bf00              NOP      
;;;232    							}
;;;233    							res1 = jd_decomp(&jdec, out_func,scale);   /* 根据缩放因子解压JPEG文件并显示 */
000300  4622              MOV      r2,r4
000302  f2af1115          ADR      r1,out_func + 1
000306  4835              LDR      r0,|L1.988|
000308  f7fffffe          BL       jd_decomp
00030c  4680              MOV      r8,r0
                  |L1.782|
;;;234    						}
;;;235    					}						
;;;236    				}
;;;237    				f_close(&fsrc);				 //关闭源文件
00030e  4830              LDR      r0,|L1.976|
000310  f7fffffe          BL       f_close
;;;238    				Delay(0xff);													   
000314  20ff              MOVS     r0,#0xff
000316  f7fffffe          BL       Delay
                  |L1.794|
00031a  a916              ADD      r1,sp,#0x58           ;195
00031c  a80f              ADD      r0,sp,#0x3c           ;195
00031e  f7fffffe          BL       f_readdir
000322  2800              CMP      r0,#0                 ;195
000324  d091              BEQ      |L1.586|
                  |L1.806|
000326  bf00              NOP                            ;199
                  |L1.808|
;;;239    			}											   
;;;240       	}
;;;241      } 
;;;242    }
000328  b01c              ADD      sp,sp,#0x70
00032a  e8bd81f0          POP      {r4-r8,pc}
;;;243    /****************************************************************************
                          ENDP

                  SD_TEST PROC
;;;250    ****************************************************************************/ 
;;;251    void SD_TEST(void)
00032e  b510              PUSH     {r4,lr}
;;;252    {
;;;253    	Status = SD_Init();
000330  f7fffffe          BL       SD_Init
000334  492a              LDR      r1,|L1.992|
000336  7008              STRB     r0,[r1,#0]
;;;254    	Status = SD_GetCardInfo(&SDCardInfo);
000338  482a              LDR      r0,|L1.996|
00033a  f7fffffe          BL       SD_GetCardInfo
00033e  4928              LDR      r1,|L1.992|
000340  7008              STRB     r0,[r1,#0]
;;;255    	Status = SD_SelectDeselect((uint32_t) (SDCardInfo.RCA << 16));
000342  4928              LDR      r1,|L1.996|
000344  f8b1104c          LDRH     r1,[r1,#0x4c]  ; SDCardInfo
000348  0408              LSLS     r0,r1,#16
00034a  f7fffffe          BL       SD_SelectDeselect
00034e  4924              LDR      r1,|L1.992|
000350  7008              STRB     r0,[r1,#0]
;;;256    	Status = SD_EnableWideBusOperation(SDIO_BusWide_4b);
000352  f44f6000          MOV      r0,#0x800
000356  f7fffffe          BL       SD_EnableWideBusOperation
00035a  4921              LDR      r1,|L1.992|
00035c  7008              STRB     r0,[r1,#0]
;;;257    	Status = SD_SetDeviceMode(SD_DMA_MODE);  
00035e  2000              MOVS     r0,#0
000360  f7fffffe          BL       SD_SetDeviceMode
000364  491e              LDR      r1,|L1.992|
000366  7008              STRB     r0,[r1,#0]
;;;258    	if (Status == SD_OK)
000368  4608              MOV      r0,r1
00036a  7800              LDRB     r0,[r0,#0]  ; Status
00036c  282a              CMP      r0,#0x2a
00036e  d107              BNE      |L1.896|
;;;259    	{
;;;260    			// 从地址0开始读取512字节  
;;;261    		Status = SD_ReadBlock(Buffer_Block_Rx, 0x00,  512); 
000370  f44f7200          MOV      r2,#0x200
000374  2100              MOVS     r1,#0
000376  481c              LDR      r0,|L1.1000|
000378  f7fffffe          BL       SD_ReadBlock
00037c  4918              LDR      r1,|L1.992|
00037e  7008              STRB     r0,[r1,#0]
                  |L1.896|
;;;262    	}
;;;263    	if(Status == SD_OK)
000380  4817              LDR      r0,|L1.992|
000382  7800              LDRB     r0,[r0,#0]  ; Status
000384  282a              CMP      r0,#0x2a
000386  d107              BNE      |L1.920|
;;;264    	{
;;;265    		// 返回成功的话，显示SD卡测试成功信息 
;;;266    		TFT_ShowString(200,100,"SD_Card_Successfully",WHITE); 
000388  f64f73ff          MOV      r3,#0xffff
00038c  a217              ADR      r2,|L1.1004|
00038e  2164              MOVS     r1,#0x64
000390  20c8              MOVS     r0,#0xc8
000392  f7fffffe          BL       TFT_ShowString
000396  e006              B        |L1.934|
                  |L1.920|
;;;267    	}
;;;268    	else
;;;269    	{	
;;;270    		TFT_ShowString(200,100,"SD_Card_Fail",WHITE);
000398  f64f73ff          MOV      r3,#0xffff
00039c  a219              ADR      r2,|L1.1028|
00039e  2164              MOVS     r1,#0x64
0003a0  20c8              MOVS     r0,#0xc8
0003a2  f7fffffe          BL       TFT_ShowString
                  |L1.934|
;;;271    	} 
;;;272    }
0003a6  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  |L1.936|
                          DCD      MaskR
                  |L1.940|
                          DCD      MaskL
                  |L1.944|
                          DCD      MaskB
                  |L1.948|
                          DCD      MaskT
                  |L1.952|
                          DCD      0x60020000
                  |L1.956|
                          DCD      ||fs||
                  |L1.960|
0003c0  2e4a5047          DCB      ".JPG",0
0003c4  00      
0003c5  00                DCB      0
0003c6  00                DCB      0
0003c7  00                DCB      0
                  |L1.968|
0003c8  2e6a7067          DCB      ".jpg",0
0003cc  00      
0003cd  00                DCB      0
0003ce  00                DCB      0
0003cf  00                DCB      0
                  |L1.976|
                          DCD      fsrc
                  |L1.980|
                          DCD      ||res||
                  |L1.984|
                          DCD      buffer
                  |L1.988|
                          DCD      jdec
                  |L1.992|
                          DCD      Status
                  |L1.996|
                          DCD      SDCardInfo
                  |L1.1000|
                          DCD      Buffer_Block_Rx
                  |L1.1004|
0003ec  53445f43          DCB      "SD_Card_Successfully",0
0003f0  6172645f
0003f4  53756363
0003f8  65737366
0003fc  756c6c79
000400  00      
000401  00                DCB      0
000402  00                DCB      0
000403  00                DCB      0
                  |L1.1028|
000404  53445f43          DCB      "SD_Card_Fail",0
000408  6172645f
00040c  4661696c
000410  00      
000411  00                DCB      0
000412  00                DCB      0
000413  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SDCardInfo
                          %        80
                  Buffer_Block_Tx
                          %        2048
                  Buffer_Block_Rx
                          %        2048
                  ||fs||
                          %        560
                  fsrc
                          %        548
                  fdst
                          %        548
                  jdec
                          %        124
                  buffer
                          %        8192

                          AREA ||.data||, DATA, ALIGN=2

                  Status
000000  2a000000          DCB      0x2a,0x00,0x00,0x00
                  MaskT
                          DCD      0x00000000
                  MaskL
                          DCD      0x00000000
                  MaskR
                          DCD      0x00000000
                  MaskB
                          DCD      0x00000000
                  ||res||
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  ||br||
                          DCD      0x00000000
                  ||bw||
                          DCD      0x00000000
