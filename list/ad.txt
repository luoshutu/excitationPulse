; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\ad.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\ad.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_翻页\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\ad.crf user\AD.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;14     ****************************************************************************/ 
;;;15     void ADC_Configuration(void)
000000  b500              PUSH     {lr}
;;;16     {
000002  b091              SUB      sp,sp,#0x44
;;;17     	ADC_InitTypeDef ADC_InitStructure;
;;;18     	GPIO_InitTypeDef GPIO_InitStructure;
;;;19     	DMA_InitTypeDef DMA_InitStructure;
;;;20     
;;;21         //设置AD模拟输入端口为输入 1路AD 规则通道
;;;22       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
000004  2010              MOVS     r0,#0x10
000006  f8ad002c          STRH     r0,[sp,#0x2c]
;;;23       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00000a  2000              MOVS     r0,#0
00000c  f88d002f          STRB     r0,[sp,#0x2f]
;;;24       	GPIO_Init(GPIOA, &GPIO_InitStructure);
000010  a90b              ADD      r1,sp,#0x2c
000012  4837              LDR      r0,|L1.240|
000014  f7fffffe          BL       GPIO_Init
;;;25     	/* Enable DMA clock */
;;;26         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;27     
;;;28        /* Enable ADC1 and GPIOC clock */
;;;29         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
000020  2101              MOVS     r1,#1
000022  0248              LSLS     r0,r1,#9
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;30     
;;;31       	/* DMA channel1 configuration ----------------------------------------------*/
;;;32     	//使能DMA
;;;33     	DMA_DeInit(DMA1_Channel1);
000028  4832              LDR      r0,|L1.244|
00002a  f7fffffe          BL       DMA_DeInit
;;;34     	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;			            //DMA通道1的地址 
00002e  4832              LDR      r0,|L1.248|
000030  9000              STR      r0,[sp,#0]
;;;35     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;	            //DMA传送地址
000032  4832              LDR      r0,|L1.252|
000034  9001              STR      r0,[sp,#4]
;;;36     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					            //传送方向
000036  2000              MOVS     r0,#0
000038  9002              STR      r0,[sp,#8]
;;;37     	DMA_InitStructure.DMA_BufferSize = 1;								            //传送内存大小，100个16位
00003a  2001              MOVS     r0,#1
00003c  9003              STR      r0,[sp,#0xc]
;;;38     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	 
00003e  2000              MOVS     r0,#0
000040  9004              STR      r0,[sp,#0x10]
;;;39     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				            //传送内存地址递增
000042  2080              MOVS     r0,#0x80
000044  9005              STR      r0,[sp,#0x14]
;;;40     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;		//ADC1转换的数据是16位
000046  0040              LSLS     r0,r0,#1
000048  9006              STR      r0,[sp,#0x18]
;;;41     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;				//传送的目的地址是16位宽度
00004a  0080              LSLS     r0,r0,#2
00004c  9007              STR      r0,[sp,#0x1c]
;;;42     	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;									//循环
00004e  2020              MOVS     r0,#0x20
000050  9008              STR      r0,[sp,#0x20]
;;;43     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000052  0200              LSLS     r0,r0,#8
000054  9009              STR      r0,[sp,#0x24]
;;;44     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000056  2000              MOVS     r0,#0
000058  900a              STR      r0,[sp,#0x28]
;;;45     	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
00005a  4669              MOV      r1,sp
00005c  4825              LDR      r0,|L1.244|
00005e  f7fffffe          BL       DMA_Init
;;;46         
;;;47     	/* 允许DMA1通道1传输结束中断 */
;;;48     	//DMA_ITConfig(DMA1_Channel1,DMA_IT_TC, ENABLE);
;;;49     
;;;50     
;;;51     	//使能DMA通道1
;;;52     	DMA_Cmd(DMA1_Channel1, ENABLE); 
000062  2101              MOVS     r1,#1
000064  4823              LDR      r0,|L1.244|
000066  f7fffffe          BL       DMA_Cmd
;;;53       
;;;54       
;;;55     	//ADC配置
;;;56     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC1工作在独立模式
00006a  2000              MOVS     r0,#0
00006c  900c              STR      r0,[sp,#0x30]
;;;57     	ADC_InitStructure.ADC_ScanConvMode = ENABLE;		//模数转换工作在扫描模式（多通道）还是单次（单通道）模式
00006e  2001              MOVS     r0,#1
000070  f88d0034          STRB     r0,[sp,#0x34]
;;;58     	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//模数转换工作在扫描模式（多通道）还是单次（单通道）模式
000074  f88d0035          STRB     r0,[sp,#0x35]
;;;59     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//转换由软件而不是外部触发启动
000078  f44f2060          MOV      r0,#0xe0000
00007c  900e              STR      r0,[sp,#0x38]
;;;60     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐
00007e  2000              MOVS     r0,#0
000080  900f              STR      r0,[sp,#0x3c]
;;;61     	ADC_InitStructure.ADC_NbrOfChannel = 1;               //规定了顺序进行规则转换的ADC通道的数目。这个数目的取值范围是1到16
000082  2001              MOVS     r0,#1
000084  f88d0040          STRB     r0,[sp,#0x40]
;;;62     	ADC_Init(ADC1, &ADC_InitStructure);
000088  a90c              ADD      r1,sp,#0x30
00008a  481b              LDR      r0,|L1.248|
00008c  384c              SUBS     r0,r0,#0x4c
00008e  f7fffffe          BL       ADC_Init
;;;63     	
;;;64     	/* ADC1 regular channels configuration [规则模式通道配置]*/ 
;;;65     
;;;66     	//ADC1 规则通道配置
;;;67       	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_55Cycles5);	  //通道11采样时间 55.5周期
000092  2305              MOVS     r3,#5
000094  2201              MOVS     r2,#1
000096  2104              MOVS     r1,#4
000098  4817              LDR      r0,|L1.248|
00009a  384c              SUBS     r0,r0,#0x4c
00009c  f7fffffe          BL       ADC_RegularChannelConfig
;;;68       	
;;;69     
;;;70     	//使能ADC1 DMA 
;;;71     	ADC_DMACmd(ADC1, ENABLE);
0000a0  2101              MOVS     r1,#1
0000a2  4815              LDR      r0,|L1.248|
0000a4  384c              SUBS     r0,r0,#0x4c
0000a6  f7fffffe          BL       ADC_DMACmd
;;;72     	//使能ADC1
;;;73     	ADC_Cmd(ADC1, ENABLE);	
0000aa  2101              MOVS     r1,#1
0000ac  4812              LDR      r0,|L1.248|
0000ae  384c              SUBS     r0,r0,#0x4c
0000b0  f7fffffe          BL       ADC_Cmd
;;;74     	
;;;75     	// 初始化ADC1校准寄存器
;;;76     	ADC_ResetCalibration(ADC1);
0000b4  4810              LDR      r0,|L1.248|
0000b6  384c              SUBS     r0,r0,#0x4c
0000b8  f7fffffe          BL       ADC_ResetCalibration
;;;77     	//检测ADC1校准寄存器初始化是否完成
;;;78     	while(ADC_GetResetCalibrationStatus(ADC1));
0000bc  bf00              NOP      
                  |L1.190|
0000be  480e              LDR      r0,|L1.248|
0000c0  384c              SUBS     r0,r0,#0x4c
0000c2  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000c6  2800              CMP      r0,#0
0000c8  d1f9              BNE      |L1.190|
;;;79     	
;;;80     	//开始校准ADC1
;;;81     	ADC_StartCalibration(ADC1);
0000ca  480b              LDR      r0,|L1.248|
0000cc  384c              SUBS     r0,r0,#0x4c
0000ce  f7fffffe          BL       ADC_StartCalibration
;;;82     	//检测是否完成校准
;;;83     	while(ADC_GetCalibrationStatus(ADC1));
0000d2  bf00              NOP      
                  |L1.212|
0000d4  4808              LDR      r0,|L1.248|
0000d6  384c              SUBS     r0,r0,#0x4c
0000d8  f7fffffe          BL       ADC_GetCalibrationStatus
0000dc  2800              CMP      r0,#0
0000de  d1f9              BNE      |L1.212|
;;;84     	
;;;85     	//ADC1转换启动
;;;86     	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	 
0000e0  2101              MOVS     r1,#1
0000e2  4805              LDR      r0,|L1.248|
0000e4  384c              SUBS     r0,r0,#0x4c
0000e6  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;87     }
0000ea  b011              ADD      sp,sp,#0x44
0000ec  bd00              POP      {pc}
;;;88     
                          ENDP

0000ee  0000              DCW      0x0000
                  |L1.240|
                          DCD      0x40010800
                  |L1.244|
                          DCD      0x40020008
                  |L1.248|
                          DCD      0x4001244c
                  |L1.252|
                          DCD      ADC_ConvertedValue

                          AREA ||.data||, DATA, ALIGN=1

                  ADC_ConvertedValue
000000  0000              DCB      0x00,0x00
