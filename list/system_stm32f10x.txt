; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\system_stm32f10x.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_·­Ò³\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\system_stm32f10x.crf CM3\system_stm32f10x.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;987      */
;;;988    static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;989    {
;;;990      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;991      
;;;992      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;993      /* Enable HSE */    
;;;994      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  486c              LDR      r0,|L1.444|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4403080          ORR      r0,r0,#0x10000
000010  496a              LDR      r1,|L1.444|
000012  6008              STR      r0,[r1,#0]
;;;995     
;;;996      /* Wait till HSE is ready and if Time out is reached exit */
;;;997      do
000014  bf00              NOP      
                  |L1.22|
;;;998      {
;;;999        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000016  4869              LDR      r0,|L1.444|
000018  6800              LDR      r0,[r0,#0]
00001a  f4003000          AND      r0,r0,#0x20000
00001e  9000              STR      r0,[sp,#0]
;;;1000       StartUpCounter++;  
000020  9801              LDR      r0,[sp,#4]
000022  1c40              ADDS     r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;1001     } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000026  9800              LDR      r0,[sp,#0]
000028  b918              CBNZ     r0,|L1.50|
00002a  9801              LDR      r0,[sp,#4]
00002c  f5b06fa0          CMP      r0,#0x500
000030  d1f1              BNE      |L1.22|
                  |L1.50|
;;;1002   
;;;1003     if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000032  4862              LDR      r0,|L1.444|
000034  6800              LDR      r0,[r0,#0]
000036  f4003000          AND      r0,r0,#0x20000
00003a  b110              CBZ      r0,|L1.66|
;;;1004     {
;;;1005       HSEStatus = (uint32_t)0x01;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L1.70|
                  |L1.66|
;;;1006     }
;;;1007     else
;;;1008     {
;;;1009       HSEStatus = (uint32_t)0x00;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L1.70|
;;;1010     }  
;;;1011   
;;;1012     if (HSEStatus == (uint32_t)0x01)
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  d143              BNE      |L1.212|
;;;1013     {
;;;1014       /* Enable Prefetch Buffer */
;;;1015       FLASH->ACR |= FLASH_ACR_PRFTBE;
00004c  485c              LDR      r0,|L1.448|
00004e  6800              LDR      r0,[r0,#0]
000050  f0400010          ORR      r0,r0,#0x10
000054  495a              LDR      r1,|L1.448|
000056  6008              STR      r0,[r1,#0]
;;;1016   
;;;1017       /* Flash 2 wait state */
;;;1018       FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200003          BIC      r0,r0,#3
000060  6008              STR      r0,[r1,#0]
;;;1019       FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f0400002          ORR      r0,r0,#2
00006a  6008              STR      r0,[r1,#0]
;;;1020   
;;;1021    
;;;1022       /* HCLK = SYSCLK */
;;;1023       RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00006c  4853              LDR      r0,|L1.444|
00006e  6840              LDR      r0,[r0,#4]
000070  4952              LDR      r1,|L1.444|
000072  6048              STR      r0,[r1,#4]
;;;1024         
;;;1025       /* PCLK2 = HCLK */
;;;1026       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]
000078  6048              STR      r0,[r1,#4]
;;;1027       
;;;1028       /* PCLK1 = HCLK */
;;;1029       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00007a  4608              MOV      r0,r1
00007c  6840              LDR      r0,[r0,#4]
00007e  f4406080          ORR      r0,r0,#0x400
000082  6048              STR      r0,[r1,#4]
;;;1030   
;;;1031   #ifdef STM32F10X_CL
;;;1032       /* Configure PLLs ------------------------------------------------------*/
;;;1033       /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1034       /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1035           
;;;1036       RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1037                                 RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1038       RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1039                                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1040     
;;;1041       /* Enable PLL2 */
;;;1042       RCC->CR |= RCC_CR_PLL2ON;
;;;1043       /* Wait till PLL2 is ready */
;;;1044       while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1045       {
;;;1046       }
;;;1047       
;;;1048      
;;;1049       /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1050       RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1051       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;1052                               RCC_CFGR_PLLMULL9); 
;;;1053   #else    
;;;1054       /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1055       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000084  4608              MOV      r0,r1
000086  6840              LDR      r0,[r0,#4]
000088  f420107c          BIC      r0,r0,#0x3f0000
00008c  6048              STR      r0,[r1,#4]
;;;1056                                           RCC_CFGR_PLLMULL));
;;;1057       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00008e  4608              MOV      r0,r1
000090  6840              LDR      r0,[r0,#4]
000092  f44010e8          ORR      r0,r0,#0x1d0000
000096  6048              STR      r0,[r1,#4]
;;;1058   #endif /* STM32F10X_CL */
;;;1059   
;;;1060       /* Enable PLL */
;;;1061       RCC->CR |= RCC_CR_PLLON;
000098  4608              MOV      r0,r1
00009a  6800              LDR      r0,[r0,#0]
00009c  f0407080          ORR      r0,r0,#0x1000000
0000a0  6008              STR      r0,[r1,#0]
;;;1062   
;;;1063       /* Wait till PLL is ready */
;;;1064       while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000a2  bf00              NOP      
                  |L1.164|
0000a4  4845              LDR      r0,|L1.444|
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f0007000          AND      r0,r0,#0x2000000
0000ac  2800              CMP      r0,#0
0000ae  d0f9              BEQ      |L1.164|
;;;1065       {
;;;1066       }
;;;1067       
;;;1068       /* Select PLL as system clock source */
;;;1069       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000b0  4842              LDR      r0,|L1.444|
0000b2  6840              LDR      r0,[r0,#4]
0000b4  f0200003          BIC      r0,r0,#3
0000b8  4940              LDR      r1,|L1.444|
0000ba  6048              STR      r0,[r1,#4]
;;;1070       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000bc  4608              MOV      r0,r1
0000be  6840              LDR      r0,[r0,#4]
0000c0  f0400002          ORR      r0,r0,#2
0000c4  6048              STR      r0,[r1,#4]
;;;1071   
;;;1072       /* Wait till PLL is used as system clock source */
;;;1073       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000c6  bf00              NOP      
                  |L1.200|
0000c8  483c              LDR      r0,|L1.444|
0000ca  6840              LDR      r0,[r0,#4]
0000cc  f000000c          AND      r0,r0,#0xc
0000d0  2808              CMP      r0,#8
0000d2  d1f9              BNE      |L1.200|
                  |L1.212|
;;;1074       {
;;;1075       }
;;;1076     }
;;;1077     else
;;;1078     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1079            configuration. User can add here some code to deal with this error */
;;;1080     }
;;;1081   }
0000d4  bd0c              POP      {r2,r3,pc}
;;;1082   #endif
                          ENDP

                  SetSysClock PROC
;;;419      */
;;;420    static void SetSysClock(void)
0000d6  b510              PUSH     {r4,lr}
;;;421    {
;;;422    #ifdef SYSCLK_FREQ_HSE
;;;423      SetSysClockToHSE();
;;;424    #elif defined SYSCLK_FREQ_24MHz
;;;425      SetSysClockTo24();
;;;426    #elif defined SYSCLK_FREQ_36MHz
;;;427      SetSysClockTo36();
;;;428    #elif defined SYSCLK_FREQ_48MHz
;;;429      SetSysClockTo48();
;;;430    #elif defined SYSCLK_FREQ_56MHz
;;;431      SetSysClockTo56();  
;;;432    #elif defined SYSCLK_FREQ_72MHz
;;;433      SetSysClockTo72();
0000d8  f7fffffe          BL       SetSysClockTo72
;;;434    #endif
;;;435     
;;;436     /* If none of the define above is enabled, the HSI is used as System clock
;;;437        source (default after reset) */ 
;;;438    }
0000dc  bd10              POP      {r4,pc}
;;;439    
                          ENDP

                  SystemInit PROC
;;;212      */
;;;213    void SystemInit (void)
0000de  b510              PUSH     {r4,lr}
;;;214    {
;;;215      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;216      /* Set HSION bit */
;;;217      RCC->CR |= (uint32_t)0x00000001;
0000e0  4836              LDR      r0,|L1.444|
0000e2  6800              LDR      r0,[r0,#0]
0000e4  f0400001          ORR      r0,r0,#1
0000e8  4934              LDR      r1,|L1.444|
0000ea  6008              STR      r0,[r1,#0]
;;;218    
;;;219      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;220    #ifndef STM32F10X_CL
;;;221      RCC->CFGR &= (uint32_t)0xF8FF0000;
0000ec  4608              MOV      r0,r1
0000ee  6840              LDR      r0,[r0,#4]
0000f0  4934              LDR      r1,|L1.452|
0000f2  4008              ANDS     r0,r0,r1
0000f4  4931              LDR      r1,|L1.444|
0000f6  6048              STR      r0,[r1,#4]
;;;222    #else
;;;223      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;224    #endif /* STM32F10X_CL */   
;;;225      
;;;226      /* Reset HSEON, CSSON and PLLON bits */
;;;227      RCC->CR &= (uint32_t)0xFEF6FFFF;
0000f8  4608              MOV      r0,r1
0000fa  6800              LDR      r0,[r0,#0]
0000fc  4932              LDR      r1,|L1.456|
0000fe  4008              ANDS     r0,r0,r1
000100  492e              LDR      r1,|L1.444|
000102  6008              STR      r0,[r1,#0]
;;;228    
;;;229      /* Reset HSEBYP bit */
;;;230      RCC->CR &= (uint32_t)0xFFFBFFFF;
000104  4608              MOV      r0,r1
000106  6800              LDR      r0,[r0,#0]
000108  f4202080          BIC      r0,r0,#0x40000
00010c  6008              STR      r0,[r1,#0]
;;;231    
;;;232      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;233      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00010e  4608              MOV      r0,r1
000110  6840              LDR      r0,[r0,#4]
000112  f42000fe          BIC      r0,r0,#0x7f0000
000116  6048              STR      r0,[r1,#4]
;;;234    
;;;235    #ifdef STM32F10X_CL
;;;236      /* Reset PLL2ON and PLL3ON bits */
;;;237      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;238    
;;;239      /* Disable all interrupts and clear pending bits  */
;;;240      RCC->CIR = 0x00FF0000;
;;;241    
;;;242      /* Reset CFGR2 register */
;;;243      RCC->CFGR2 = 0x00000000;
;;;244    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;245      /* Disable all interrupts and clear pending bits  */
;;;246      RCC->CIR = 0x009F0000;
;;;247    
;;;248      /* Reset CFGR2 register */
;;;249      RCC->CFGR2 = 0x00000000;      
;;;250    #else
;;;251      /* Disable all interrupts and clear pending bits  */
;;;252      RCC->CIR = 0x009F0000;
000118  f44f001f          MOV      r0,#0x9f0000
00011c  6088              STR      r0,[r1,#8]
;;;253    #endif /* STM32F10X_CL */
;;;254        
;;;255    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;256      #ifdef DATA_IN_ExtSRAM
;;;257        SystemInit_ExtMemCtl(); 
;;;258      #endif /* DATA_IN_ExtSRAM */
;;;259    #endif 
;;;260    
;;;261      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;262      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;263      SetSysClock();
00011e  f7fffffe          BL       SetSysClock
;;;264    
;;;265    #ifdef VECT_TAB_SRAM
;;;266      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;267    #else
;;;268      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000122  f04f6000          MOV      r0,#0x8000000
000126  4929              LDR      r1,|L1.460|
000128  6008              STR      r0,[r1,#0]
;;;269    #endif 
;;;270    }
00012a  bd10              POP      {r4,pc}
;;;271    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;306      */
;;;307    void SystemCoreClockUpdate (void)
00012c  b510              PUSH     {r4,lr}
;;;308    {
;;;309      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
00012e  2100              MOVS     r1,#0
000130  2000              MOVS     r0,#0
000132  2200              MOVS     r2,#0
;;;310    
;;;311    #ifdef  STM32F10X_CL
;;;312      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;313    #endif /* STM32F10X_CL */
;;;314    
;;;315    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;316      uint32_t prediv1factor = 0;
;;;317    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;318        
;;;319      /* Get SYSCLK source -------------------------------------------------------*/
;;;320      tmp = RCC->CFGR & RCC_CFGR_SWS;
000134  4b21              LDR      r3,|L1.444|
000136  685b              LDR      r3,[r3,#4]
000138  f003010c          AND      r1,r3,#0xc
;;;321      
;;;322      switch (tmp)
00013c  b121              CBZ      r1,|L1.328|
00013e  2904              CMP      r1,#4
000140  d006              BEQ      |L1.336|
000142  2908              CMP      r1,#8
000144  d128              BNE      |L1.408|
000146  e007              B        |L1.344|
                  |L1.328|
;;;323      {
;;;324        case 0x00:  /* HSI used as system clock */
;;;325          SystemCoreClock = HSI_VALUE;
000148  4b21              LDR      r3,|L1.464|
00014a  4c22              LDR      r4,|L1.468|
00014c  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;326          break;
00014e  e027              B        |L1.416|
                  |L1.336|
;;;327        case 0x04:  /* HSE used as system clock */
;;;328          SystemCoreClock = HSE_VALUE;
000150  4b1f              LDR      r3,|L1.464|
000152  4c20              LDR      r4,|L1.468|
000154  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;329          break;
000156  e023              B        |L1.416|
                  |L1.344|
;;;330        case 0x08:  /* PLL used as system clock */
;;;331    
;;;332          /* Get PLL clock source and multiplication factor ----------------------*/
;;;333          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
000158  4b18              LDR      r3,|L1.444|
00015a  685b              LDR      r3,[r3,#4]
00015c  f4031070          AND      r0,r3,#0x3c0000
;;;334          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000160  4b16              LDR      r3,|L1.444|
000162  685b              LDR      r3,[r3,#4]
000164  f4033280          AND      r2,r3,#0x10000
;;;335          
;;;336    #ifndef STM32F10X_CL      
;;;337          pllmull = ( pllmull >> 18) + 2;
000168  2302              MOVS     r3,#2
00016a  eb034090          ADD      r0,r3,r0,LSR #18
;;;338          
;;;339          if (pllsource == 0x00)
00016e  b922              CBNZ     r2,|L1.378|
;;;340          {
;;;341            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;342            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
000170  4b19              LDR      r3,|L1.472|
000172  4343              MULS     r3,r0,r3
000174  4c17              LDR      r4,|L1.468|
000176  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000178  e00d              B        |L1.406|
                  |L1.378|
;;;343          }
;;;344          else
;;;345          {
;;;346     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;347           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;348           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;349           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;350     #else
;;;351            /* HSE selected as PLL clock entry */
;;;352            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
00017a  4b10              LDR      r3,|L1.444|
00017c  685b              LDR      r3,[r3,#4]
00017e  f4033300          AND      r3,r3,#0x20000
000182  b123              CBZ      r3,|L1.398|
;;;353            {/* HSE oscillator clock divided by 2 */
;;;354              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
000184  4b14              LDR      r3,|L1.472|
000186  4343              MULS     r3,r0,r3
000188  4c12              LDR      r4,|L1.468|
00018a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00018c  e003              B        |L1.406|
                  |L1.398|
;;;355            }
;;;356            else
;;;357            {
;;;358              SystemCoreClock = HSE_VALUE * pllmull;
00018e  4b10              LDR      r3,|L1.464|
000190  4343              MULS     r3,r0,r3
000192  4c10              LDR      r4,|L1.468|
000194  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L1.406|
;;;359            }
;;;360     #endif
;;;361          }
;;;362    #else
;;;363          pllmull = pllmull >> 18;
;;;364          
;;;365          if (pllmull != 0x0D)
;;;366          {
;;;367             pllmull += 2;
;;;368          }
;;;369          else
;;;370          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;371            pllmull = 13 / 2; 
;;;372          }
;;;373                
;;;374          if (pllsource == 0x00)
;;;375          {
;;;376            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;377            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;378          }
;;;379          else
;;;380          {/* PREDIV1 selected as PLL clock entry */
;;;381            
;;;382            /* Get PREDIV1 clock source and division factor */
;;;383            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;384            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;385            
;;;386            if (prediv1source == 0)
;;;387            { 
;;;388              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;389              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;390            }
;;;391            else
;;;392            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;393              
;;;394              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;395              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;396              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;397              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;398            }
;;;399          }
;;;400    #endif /* STM32F10X_CL */ 
;;;401          break;
000196  e003              B        |L1.416|
                  |L1.408|
;;;402    
;;;403        default:
;;;404          SystemCoreClock = HSI_VALUE;
000198  4b0d              LDR      r3,|L1.464|
00019a  4c0e              LDR      r4,|L1.468|
00019c  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;405          break;
00019e  bf00              NOP      
                  |L1.416|
0001a0  bf00              NOP                            ;326
;;;406      }
;;;407      
;;;408      /* Compute HCLK clock frequency ----------------*/
;;;409      /* Get HCLK prescaler */
;;;410      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
0001a2  4b06              LDR      r3,|L1.444|
0001a4  685b              LDR      r3,[r3,#4]
0001a6  f3c31303          UBFX     r3,r3,#4,#4
0001aa  4c0c              LDR      r4,|L1.476|
0001ac  5ce1              LDRB     r1,[r4,r3]
;;;411      /* HCLK clock frequency */
;;;412      SystemCoreClock >>= tmp;  
0001ae  4b09              LDR      r3,|L1.468|
0001b0  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
0001b2  40cb              LSRS     r3,r3,r1
0001b4  4c07              LDR      r4,|L1.468|
0001b6  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;413    }
0001b8  bd10              POP      {r4,pc}
;;;414    
                          ENDP

0001ba  0000              DCW      0x0000
                  |L1.444|
                          DCD      0x40021000
                  |L1.448|
                          DCD      0x40022000
                  |L1.452|
                          DCD      0xf8ff0000
                  |L1.456|
                          DCD      0xfef6ffff
                  |L1.460|
                          DCD      0xe000ed08
                  |L1.464|
                          DCD      0x007a1200
                  |L1.468|
                          DCD      SystemCoreClock
                  |L1.472|
                          DCD      0x003d0900
                  |L1.476|
                          DCD      AHBPrescTable

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
