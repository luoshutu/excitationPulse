; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gt9147.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gt9147.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -IF:\excitationPulse\Ver_F8_翻页\RTE -ID:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gt9147.crf user\gt9147.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GT_SDA_IN PROC
;;;13     
;;;14     void GT_SDA_IN(void)  
000000  b508              PUSH     {r3,lr}
;;;15     {
;;;16       GPIO_InitTypeDef  GPIO_InitStructure;  
;;;17       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;	     
000002  2040              MOVS     r0,#0x40
000004  f8ad0000          STRH     r0,[sp,#0]
;;;18       GPIO_InitStructure.GPIO_Mode =GPIO_Mode_IN_FLOATING; 
000008  2004              MOVS     r0,#4
00000a  f88d0003          STRB     r0,[sp,#3]
;;;19       GPIO_Init(GPIOA, &GPIO_InitStructure);
00000e  4669              MOV      r1,sp
000010  486a              LDR      r0,|L1.444|
000012  f7fffffe          BL       GPIO_Init
;;;20     }
000016  bd08              POP      {r3,pc}
;;;21     void GT_SDA_OUT(void) {
                          ENDP

                  GT_SDA_OUT PROC
000018  b508              PUSH     {r3,lr}
;;;22       GPIO_InitTypeDef  GPIO_InitStructure; 
;;;23       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00001a  2040              MOVS     r0,#0x40
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;24       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0002          STRB     r0,[sp,#2]
;;;25       GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_PP ;//  
000026  2010              MOVS     r0,#0x10
000028  f88d0003          STRB     r0,[sp,#3]
;;;26       GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4863              LDR      r0,|L1.444|
000030  f7fffffe          BL       GPIO_Init
;;;27     }
000034  bd08              POP      {r3,pc}
;;;28     
                          ENDP

                  delay_us PROC
;;;59     ****************************************************************************/
;;;60     void delay_us(__IO uint32_t nTime)
000036  b501              PUSH     {r0,lr}
;;;61     {	
;;;62       
;;;63        while(nTime) 
000038  e002              B        |L1.64|
                  |L1.58|
;;;64        { 
;;;65          nTime--; 
00003a  9800              LDR      r0,[sp,#0]
00003c  1e40              SUBS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
                  |L1.64|
000040  9800              LDR      r0,[sp,#0]            ;63
000042  2800              CMP      r0,#0                 ;63
000044  d1f9              BNE      |L1.58|
;;;66        } 
;;;67     }
000046  bd08              POP      {r3,pc}
;;;68     //向GT9147写入一次数据
                          ENDP

                  GT9147_WR_Reg PROC
;;;72     //返回值:0：成功;1：失败.
;;;73     unsigned char GT9147_WR_Reg(unsigned short reg,unsigned char *buf,unsigned char len)
000048  e92d41f0          PUSH     {r4-r8,lr}
;;;74     {
00004c  4604              MOV      r4,r0
00004e  460e              MOV      r6,r1
000050  4617              MOV      r7,r2
;;;75     	unsigned char i;
;;;76     	unsigned char res=0;
000052  f04f0800          MOV      r8,#0
;;;77     	GT_I2C_Start();	
000056  f7fffffe          BL       GT_I2C_Start
;;;78      	GT_I2C_Send_Byte(GT_CMD_WR);   	//发送写命令 	 
00005a  2070              MOVS     r0,#0x70
00005c  f7fffffe          BL       GT_I2C_Send_Byte
;;;79     	GT_I2C_Wait_Ack();
000060  f7fffffe          BL       GT_I2C_Wait_Ack
;;;80     	GT_I2C_Send_Byte(reg>>8);   	//发送高8位地址
000064  1220              ASRS     r0,r4,#8
000066  f7fffffe          BL       GT_I2C_Send_Byte
;;;81     	GT_I2C_Wait_Ack(); 	 										  		   
00006a  f7fffffe          BL       GT_I2C_Wait_Ack
;;;82     	GT_I2C_Send_Byte(reg&0XFF);   	//发送低8位地址
00006e  b2e0              UXTB     r0,r4
000070  f7fffffe          BL       GT_I2C_Send_Byte
;;;83     	GT_I2C_Wait_Ack();  
000074  f7fffffe          BL       GT_I2C_Wait_Ack
;;;84     	for(i=0;i<len;i++)
000078  2500              MOVS     r5,#0
00007a  e00b              B        |L1.148|
                  |L1.124|
;;;85     	{	   
;;;86         GT_I2C_Send_Byte(buf[i]);  	//发数据
00007c  5d70              LDRB     r0,[r6,r5]
00007e  f7fffffe          BL       GT_I2C_Send_Byte
;;;87     		res=GT_I2C_Wait_Ack();
000082  f7fffffe          BL       GT_I2C_Wait_Ack
000086  4680              MOV      r8,r0
;;;88     		if(res) break;  
000088  f1b80f00          CMP      r8,#0
00008c  d000              BEQ      |L1.144|
00008e  e003              B        |L1.152|
                  |L1.144|
000090  1c68              ADDS     r0,r5,#1              ;84
000092  b2c5              UXTB     r5,r0                 ;84
                  |L1.148|
000094  42bd              CMP      r5,r7                 ;84
000096  dbf1              BLT      |L1.124|
                  |L1.152|
000098  bf00              NOP      
;;;89     	}
;;;90       GT_I2C_Stop();					//产生一个停止条件	    
00009a  f7fffffe          BL       GT_I2C_Stop
;;;91     	return res; 
00009e  4640              MOV      r0,r8
;;;92     }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;93     ///////////////////////////////////////////////
                          ENDP

                  GT9147_RD_Reg PROC
;;;98     ///////////////////////////////////////////////		  
;;;99     void GT9147_RD_Reg(unsigned short reg,unsigned char *buf,unsigned char len)
0000a4  e92d41f0          PUSH     {r4-r8,lr}
;;;100    {
0000a8  4605              MOV      r5,r0
0000aa  460f              MOV      r7,r1
0000ac  4616              MOV      r6,r2
;;;101    	unsigned char i=0; 
0000ae  2400              MOVS     r4,#0
;;;102     	GT_I2C_Start();	
0000b0  f7fffffe          BL       GT_I2C_Start
;;;103     	GT_I2C_Send_Byte(GT_CMD_WR);    //发送写指令 	 
0000b4  2070              MOVS     r0,#0x70
0000b6  f7fffffe          BL       GT_I2C_Send_Byte
;;;104    	GT_I2C_Wait_Ack();
0000ba  f7fffffe          BL       GT_I2C_Wait_Ack
;;;105     	GT_I2C_Send_Byte(reg>>8);   	//发送高8位地址
0000be  1228              ASRS     r0,r5,#8
0000c0  f7fffffe          BL       GT_I2C_Send_Byte
;;;106    	GT_I2C_Wait_Ack(); 	 										  		   
0000c4  f7fffffe          BL       GT_I2C_Wait_Ack
;;;107     	GT_I2C_Send_Byte(reg&0XFF);   	//发送低8位地址
0000c8  b2e8              UXTB     r0,r5
0000ca  f7fffffe          BL       GT_I2C_Send_Byte
;;;108    	GT_I2C_Wait_Ack();  
0000ce  f7fffffe          BL       GT_I2C_Wait_Ack
;;;109     	GT_I2C_Start();  	 	   
0000d2  f7fffffe          BL       GT_I2C_Start
;;;110    	GT_I2C_Send_Byte(GT_CMD_RD);    //发送读指令		   
0000d6  2071              MOVS     r0,#0x71
0000d8  f7fffffe          BL       GT_I2C_Send_Byte
;;;111    	GT_I2C_Wait_Ack();	   
0000dc  f7fffffe          BL       GT_I2C_Wait_Ack
;;;112    	for(i=0;i<len;i++)
0000e0  bf00              NOP      
0000e2  e00b              B        |L1.252|
                  |L1.228|
;;;113    	{	   
;;;114        buf[i]=GT_I2C_Read_Byte(i==(len-1)?0:1); //发数据	
0000e4  1e71              SUBS     r1,r6,#1
0000e6  42a1              CMP      r1,r4
0000e8  d001              BEQ      |L1.238|
0000ea  2101              MOVS     r1,#1
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  2100              MOVS     r1,#0
                  |L1.240|
0000f0  4608              MOV      r0,r1
0000f2  f7fffffe          BL       GT_I2C_Read_Byte
0000f6  5538              STRB     r0,[r7,r4]
0000f8  1c60              ADDS     r0,r4,#1              ;112
0000fa  b2c4              UXTB     r4,r0                 ;112
                  |L1.252|
0000fc  42b4              CMP      r4,r6                 ;112
0000fe  dbf1              BLT      |L1.228|
;;;115    	} 
;;;116      GT_I2C_Stop();                  //产生一个停止条件    
000100  f7fffffe          BL       GT_I2C_Stop
;;;117    } 
000104  e8bd81f0          POP      {r4-r8,pc}
;;;118    
                          ENDP

                  GT9147_Init PROC
;;;122    //////////////////////////////////////////////
;;;123    unsigned char GT9147_Init(void)
000108  b508              PUSH     {r3,lr}
;;;124    {
;;;125    	GPIO_InitTypeDef GPIO_InitStructure;
;;;126    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;				                 //
00010a  20c0              MOVS     r0,#0xc0
00010c  f8ad0000          STRH     r0,[sp,#0]
;;;127    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000110  2010              MOVS     r0,#0x10
000112  f88d0003          STRB     r0,[sp,#3]
;;;128    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000116  2003              MOVS     r0,#3
000118  f88d0002          STRB     r0,[sp,#2]
;;;129    	GPIO_Init(GPIOB, &GPIO_InitStructure);	 
00011c  4669              MOV      r1,sp
00011e  4828              LDR      r0,|L1.448|
000120  f7fffffe          BL       GPIO_Init
;;;130    	GPIO_SetBits(GPIOB, GPIO_Pin_6);	
000124  2140              MOVS     r1,#0x40
000126  4826              LDR      r0,|L1.448|
000128  f7fffffe          BL       GPIO_SetBits
;;;131    	GPIO_SetBits(GPIOB, GPIO_Pin_7); //GT9147 复位引脚  
00012c  2180              MOVS     r1,#0x80
00012e  4824              LDR      r0,|L1.448|
000130  f7fffffe          BL       GPIO_SetBits
;;;132    
;;;133    	GT_I2C_Init();      	//初始化电容屏的I2C总线  
000134  f7fffffe          BL       GT_I2C_Init
;;;134    	GT_RST_L;				//电容触摸芯片复位
000138  2180              MOVS     r1,#0x80
00013a  4821              LDR      r0,|L1.448|
00013c  f7fffffe          BL       GPIO_ResetBits
;;;135    	delay_us(1000000);
000140  4820              LDR      r0,|L1.452|
000142  f7fffffe          BL       delay_us
;;;136     	GT_RST_H;				//释放复位 
000146  2180              MOVS     r1,#0x80
000148  481d              LDR      r0,|L1.448|
00014a  f7fffffe          BL       GPIO_SetBits
;;;137    	delay_us(1000000);
00014e  481d              LDR      r0,|L1.452|
000150  f7fffffe          BL       delay_us
;;;138    
;;;139    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;	        //GT9147中断信号输出引脚			               
000154  2040              MOVS     r0,#0x40
000156  f8ad0000          STRH     r0,[sp,#0]
;;;140    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;         
00015a  2028              MOVS     r0,#0x28
00015c  f88d0003          STRB     r0,[sp,#3]
;;;141    //	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;142    	GPIO_Init(GPIOB, &GPIO_InitStructure);	 
000160  4669              MOV      r1,sp
000162  4817              LDR      r0,|L1.448|
000164  f7fffffe          BL       GPIO_Init
;;;143     	delay_us(1000000);
000168  4816              LDR      r0,|L1.452|
00016a  f7fffffe          BL       delay_us
;;;144    
;;;145    	return 0;
00016e  2000              MOVS     r0,#0
;;;146    }
000170  bd08              POP      {r3,pc}
;;;147    
                          ENDP

                  GT9147_Scan PROC
;;;152    ////////////////////////////////////////////////////////////////
;;;153    unsigned char GT9147_Scan(void)
000172  b51c              PUSH     {r2-r4,lr}
;;;154    {	
;;;155    	unsigned char buf[7]={0};
000174  2000              MOVS     r0,#0
000176  9000              STR      r0,[sp,#0]
000178  9001              STR      r0,[sp,#4]
;;;156    	unsigned char res=0;
00017a  2400              MOVS     r4,#0
;;;157    	 
;;;158    	GT9147_RD_Reg(GT_TP_REG,buf,7);	        //读取XY坐标值
00017c  2207              MOVS     r2,#7
00017e  4669              MOV      r1,sp
000180  2080              MOVS     r0,#0x80
000182  f7fffffe          BL       GT9147_RD_Reg
;;;159    	if(buf[2] == 1)
000186  f89d0002          LDRB     r0,[sp,#2]
00018a  2801              CMP      r0,#1
00018c  d113              BNE      |L1.438|
;;;160    	{
;;;161    		TP_P[0][0] = ((unsigned short)(buf[3]&0x01)<<8) + buf[4];  //X坐标
00018e  f89d0004          LDRB     r0,[sp,#4]
000192  f89d1003          LDRB     r1,[sp,#3]
000196  f0010101          AND      r1,r1,#1
00019a  eb002001          ADD      r0,r0,r1,LSL #8
00019e  490a              LDR      r1,|L1.456|
0001a0  8008              STRH     r0,[r1,#0]
;;;162    		TP_P[0][1] = ((unsigned short)buf[5]<<8) + buf[6];  //Y坐标	
0001a2  f89d0006          LDRB     r0,[sp,#6]
0001a6  f89d1005          LDRB     r1,[sp,#5]
0001aa  eb002001          ADD      r0,r0,r1,LSL #8
0001ae  4906              LDR      r1,|L1.456|
0001b0  8048              STRH     r0,[r1,#2]
;;;163    		res = 1;	
0001b2  2401              MOVS     r4,#1
0001b4  e000              B        |L1.440|
                  |L1.438|
;;;164    	}
;;;165    	else res = 0;
0001b6  2400              MOVS     r4,#0
                  |L1.440|
;;;166    
;;;167    	return res;
0001b8  4620              MOV      r0,r4
;;;168    }
0001ba  bd1c              POP      {r2-r4,pc}
;;;169     
                          ENDP

                  |L1.444|
                          DCD      0x40010800
                  |L1.448|
                          DCD      0x40010c00
                  |L1.452|
                          DCD      0x000f4240
                  |L1.456|
                          DCD      TP_P

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  TP_P
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  GT9147_CONFIG_TB
000000  60e00120          DCB      0x60,0xe0,0x01,0x20
000004  03053500          DCB      0x03,0x05,0x35,0x00
000008  02081e08          DCB      0x02,0x08,0x1e,0x08
00000c  503c0f05          DCB      0x50,0x3c,0x0f,0x05
000010  0000ff67          DCB      0x00,0x00,0xff,0x67
000014  50000018          DCB      0x50,0x00,0x00,0x18
000018  1a1e1489          DCB      0x1a,0x1e,0x14,0x89
00001c  280a302e          DCB      0x28,0x0a,0x30,0x2e
000020  bb0a0300          DCB      0xbb,0x0a,0x03,0x00
000024  0002331d          DCB      0x00,0x02,0x33,0x1d
000028  00000000          DCB      0x00,0x00,0x00,0x00
00002c  00000032          DCB      0x00,0x00,0x00,0x32
000030  00002a1c          DCB      0x00,0x00,0x2a,0x1c
000034  5a94c502          DCB      0x5a,0x94,0xc5,0x02
000038  07000000          DCB      0x07,0x00,0x00,0x00
00003c  b51f0090          DCB      0xb5,0x1f,0x00,0x90
000040  28007732          DCB      0x28,0x00,0x77,0x32
000044  00623f00          DCB      0x00,0x62,0x3f,0x00
000048  52500052          DCB      0x52,0x50,0x00,0x52
00004c  00000000          DCB      0x00,0x00,0x00,0x00
000050  00000000          DCB      0x00,0x00,0x00,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
000058  00000000          DCB      0x00,0x00,0x00,0x00
00005c  00000000          DCB      0x00,0x00,0x00,0x00
000060  0000000f          DCB      0x00,0x00,0x00,0x0f
000064  0f030610          DCB      0x0f,0x03,0x06,0x10
000068  42f80f14          DCB      0x42,0xf8,0x0f,0x14
00006c  00000000          DCB      0x00,0x00,0x00,0x00
000070  1a181614          DCB      0x1a,0x18,0x16,0x14
000074  12100e0c          DCB      0x12,0x10,0x0e,0x0c
000078  0a080000          DCB      0x0a,0x08,0x00,0x00
00007c  00000000          DCB      0x00,0x00,0x00,0x00
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  00000000          DCB      0x00,0x00,0x00,0x00
000088  00000000          DCB      0x00,0x00,0x00,0x00
00008c  00002928          DCB      0x00,0x00,0x29,0x28
000090  2422201f          DCB      0x24,0x22,0x20,0x1f
000094  1e1d0e0c          DCB      0x1e,0x1d,0x0e,0x0c
000098  0a080605          DCB      0x0a,0x08,0x06,0x05
00009c  040200ff          DCB      0x04,0x02,0x00,0xff
0000a0  00000000          DCB      0x00,0x00,0x00,0x00
0000a4  00000000          DCB      0x00,0x00,0x00,0x00
0000a8  000000ff          DCB      0x00,0x00,0x00,0xff
0000ac  ffffffff          DCB      0xff,0xff,0xff,0xff
0000b0  ffffffff          DCB      0xff,0xff,0xff,0xff
0000b4  ffffffff          DCB      0xff,0xff,0xff,0xff
